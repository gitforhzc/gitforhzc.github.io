<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ONE FOR ALL</title>
  
  <subtitle>ALL FOR ONE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gitforhzc.github.io/"/>
  <updated>2019-06-08T11:05:57.603Z</updated>
  <id>http://gitforhzc.github.io/</id>
  
  <author>
    <name>hzc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gitforhzc.github.io/2019/06/08/hello-world/"/>
    <id>http://gitforhzc.github.io/2019/06/08/hello-world/</id>
    <published>2019-06-08T11:05:57.603Z</published>
    <updated>2019-06-08T11:05:57.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr><h2 id="谨记"><a href="#谨记" class="headerlink" title="谨记"></a>谨记</h2><h3 id="东京残响"><a href="#东京残响" class="headerlink" title="东京残响"></a>东京残响</h3><p>德尔斐的阿波罗神庙入口处刻着三句箴言：<br><strong>认识你自己（Γνώθι σεαυτόν） 适可而止（μηδεν αγαν） 轻诺即伤害（Ἑγγύα πάρα δ’ἄτη ）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://gitforhzc.github.io/2016/09/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://gitforhzc.github.io/2016/09/06/软件测试/</id>
    <published>2016-09-06T07:21:59.000Z</published>
    <updated>2019-06-08T11:05:57.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="软件测试定义"><a href="#软件测试定义" class="headerlink" title="软件测试定义"></a>软件测试定义</h1><blockquote><p>1983 of IEEE Standard 729：<br>使用人工或自动手段来运行或者测试某个系统的过程<br>其目的在于检验它是否满足规定的需求或是弄清楚预期结果与实际结果之间的差别。</p></blockquote><p>软件测试是<strong>验证</strong>和<strong>有效性确认</strong>构成的整体。</p><ul><li>“验证”是检验软件是否已正确地实现了产品规格书所定义的系统功能和特性</li><li>“有效性确认”是确认所开发的软件是否满足用户真正需求的活动。</li></ul><blockquote><p>下面关于软件测试，描述正确的是？(<abcd>)<br>A．软件测试是使用人工操作或者软件自动运行的方式来检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别的过程。<br>B．软件测试的测试目标是发现一些可以通过测试避免的开发风险。<br>C．软件测试的原则之一是测试应该尽早进行，最好在需求阶段就开始介入<br>D．软件测试主要工作内容是验证（verification）和确认（validation）</abcd></p></blockquote><a id="more"></a><h2 id="软件测试的对象"><a href="#软件测试的对象" class="headerlink" title="软件测试的对象"></a>软件测试的对象</h2><p>软件的含义:<br>软件 = 程序 + 数据 （库） + 文档 + 服务</p><ul><li>能够完成预定功能和性能的、可执行的指令(计算机程序)；</li><li>使得程序能够适当地操作信息的数据结构；</li><li>描述程序的操作和使用的文档。  </li></ul><blockquote><p>软件测试的对象包括 (<b>)<br>A．目标程序和相关文档<br>B．源程序、目标程序、数据及相关文档<br>C．目标程序、操作系统和平台软件<br>D．源程序和目标程序</b></p></blockquote><h1 id="测试过程模型"><a href="#测试过程模型" class="headerlink" title="测试过程模型"></a>测试过程模型</h1><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><p>V模型是瀑布模型的变种，体现开发与测试的关系<br><img src="vmodel.png" alt></p><h2 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h2><p>W模型更加强调开发与测试的同步进行<br><img src="wmodel.png" alt></p><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><p><img src="TDD.png" alt>  </p><ul><li>明确当前要完成的功能。可以记录成一个 TODO 列表。</li><li>快速完成针对此功能的测试用例编写。</li><li>测试代码编译通过。</li><li>编写对应的功能代码。</li><li>测试通过。</li><li>对代码进行重构，并保证测试通过。</li><li>循环完成所有功能的开发。</li></ul><blockquote><p>有关”测试驱动开发”，下列说法正确的有？(<abcd>)<br>A．TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码<br>B．TDD的基本思路就是通过测试来推动整个开发得进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。<br>C．TDD的重要目的不仅仅是测试软件，测试工作保证代码质量仅仅是其中一部分，而且是在开发过程中帮助客户和程序员去除模棱两可的需求。<br>D．TDD首先考虑使用需求（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。</abcd></p></blockquote><h2 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h2><h2 id="Tmap模型"><a href="#Tmap模型" class="headerlink" title="Tmap模型"></a>Tmap模型</h2><p>TMap (Test Management Approach，测试管理方法)是一种结构化的、基于风险策略的测试方法体系, 目的能更早地发现缺陷，以最小的成本、有效地、彻底地完成测试任务，以减少软件发布后的支持成本。<br>TMap所定义的测试生命周期由计划和控制、准备、说明、执行和完成等阶段组成</p><hr><h1 id="测试过程改进模型"><a href="#测试过程改进模型" class="headerlink" title="测试过程改进模型"></a>测试过程改进模型</h1><h2 id="软件能力成熟度模型CMM"><a href="#软件能力成熟度模型CMM" class="headerlink" title="软件能力成熟度模型CMM"></a>软件能力成熟度模型CMM</h2><p>CMM即软件能力成熟度模型（Capability Maturity Model）是向软件组织提供如何增加对其开发和维护软件过程的控制能力。设计并实施CMM是为了指导软件组织<br>通过关注一组有限的活动，并为实现它们而积极工作，组织能稳步地改善其软件过程，使其软件过程能力持续不断地增长。</p><h3 id="CMM的五个等级及关键过程域"><a href="#CMM的五个等级及关键过程域" class="headerlink" title="CMM的五个等级及关键过程域"></a>CMM的五个等级及关键过程域</h3><p>通过确定当前过程的成熟度等级和识别出对软件质量和过程改进至关重要的问题，来选择其过程改进策略。<br><img src="cmm.png" alt></p><p><em>软件能力成熟度模型 CMM ( Capability Maturity Model)</em></p><blockquote><p>关于测试驱动开发，描述错误的是 (C)<br>A．测试驱动开发式是一种敏捷开发方法<br>B．TDD需求开发人员学习测试相关知识<br>C．测试驱动开发不适合使用CMM/CMMI方法<br>D．测试驱动开发可以和结对编程结合使用  </p></blockquote><h2 id="TMM"><a href="#TMM" class="headerlink" title="TMM"></a>TMM</h2><p>过程能力描述了遵循一个软件测试过程可能达到的预期结果的范围。TMM的建立，得益于以下3点：</p><ul><li>充分吸收、CMM的精华；</li><li>基于历史演化的测试过程；</li><li>业界的最佳实践。  </li></ul><h3 id="TMM的5个级别简要描述"><a href="#TMM的5个级别简要描述" class="headerlink" title="TMM的5个级别简要描述"></a>TMM的5个级别简要描述</h3><p>5个别级的一系列测试能力成熟度的定义，每个级别的组成包括到期目标、到期子目标活动、任务和职责等。<br><img src="tmm.png" alt></p><h2 id="CTP"><a href="#CTP" class="headerlink" title="CTP"></a>CTP</h2><p>关键测试过程（Critical Test Process，CTP）<br>使用CTP的过程改进，始于对现有测试过程的评估，通过评估以识别过程的强弱，并结合组织的需要提供改进的意见</p><h1 id="软件测试阶段"><a href="#软件测试阶段" class="headerlink" title="软件测试阶段"></a>软件测试阶段</h1><p><img src="testing.png" alt></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试的对象是程序系统中的最小单元–模块或组件上，在编码阶段进行，针对每个模块进行测试。<br>单元测试一般由编程人员和测试人员共同完成，而以开发人员为主。   </p><ul><li>目标：确保模块被正确地编码</li><li>依据：详细设计描述</li><li>过程：设计、脚本开发、执行、调试、分析结果</li><li>执行者：测试人员和开发人员</li><li>测试方法：白盒方法为主，辅以黑盒方法</li><li>评估：通过所有单元测试用例，代码没有严重缺陷</li></ul><h3 id="单元测试管理"><a href="#单元测试管理" class="headerlink" title="单元测试管理"></a>单元测试管理</h3><h3 id="单元测试文档"><a href="#单元测试文档" class="headerlink" title="单元测试文档"></a>单元测试文档</h3><h3 id="单元测试工具"><a href="#单元测试工具" class="headerlink" title="单元测试工具"></a>单元测试工具</h3><h3 id="单元测试技术"><a href="#单元测试技术" class="headerlink" title="单元测试技术"></a>单元测试技术</h3><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>利用查看代码功能和实现方式得到的信息来确定哪些要测试，哪些不要测试，如何开展测试。<br>白盒测试针对的是程序内部逻辑和数据流程的测试，主要有逻辑驱动法和基本路径法。</p><h5 id="逻辑覆盖法"><a href="#逻辑覆盖法" class="headerlink" title="逻辑覆盖法"></a>逻辑覆盖法</h5><p>以程序的内部逻辑结构为基础</p><h6 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h6><p><strong>基本思想</strong><br>设计若干测试用例，运行被测程序，使程序中的每个可执行语句至少被执行一次</p><ul><li>顺序结构<br>让测试从头执行到尾</li><li>分支、条件和循环结构<br>利用执行的测试覆盖全部语句  </li></ul><p>它是最弱的逻辑覆盖准，效果有限，必须与其他方法交互使用。</p><h6 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h6><p>设计若干用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次，即判断真假值均曾被满足。  </p><p>判定覆盖只比语句覆盖稍强一些，但实际效果表明，只是判定覆盖，还不能保证一定能查出在判断的条件中存在的错误。因此，还需要更强的逻辑覆盖准则去检验判断内部条件。</p><h6 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h6><p>设计若干测试用例，执行被测程序以后，要使每个判断中每个条件的可能取值至少满足一次。  </p><p>条件覆盖深入到判定中的每个条件，但可能不能满足判定覆盖的要求。</p><h6 id="判定－条件覆盖"><a href="#判定－条件覆盖" class="headerlink" title="判定－条件覆盖"></a>判定－条件覆盖</h6><p>设计足够的测试用例，使得判断条件中的所有条件可能取值至少执行一次，同时，所有判断的可能结果至少执行一次  </p><p>判定－条件覆盖有缺陷。从表面上来看，它测试了所有条件的取值。但是事实并非如此。往往某些条件掩盖了另一些条件。会遗漏某些条件取值错误的情况。为彻底地检查所有条件的取值，需要将判定语句中给出的复合条件表达式进行分解，形成由多个基本判定嵌套的流程图。这样就可以有效地检查所有的条件是否正确了。</p><h6 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h6><p>设计足够的测试用例，使得判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果也至少出现一次。  </p><p>这是一种相当强的覆盖准则，可以有效地检查各种可能的条件取值的组合是否正确。它不但可覆盖所有条件的可能取值的组合，还可覆盖所有判断的可取分支，但可能有的路径会遗漏掉。测试还不完全。</p><h6 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h6><p>设计所有的测试用例，来覆盖程序中的所有可能的执行路径。</p><p>这是最强的覆盖准则。</p><h5 id="基本路径法"><a href="#基本路径法" class="headerlink" title="基本路径法"></a>基本路径法</h5><p>在程序控制流程的基础上，分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例。</p><ol><li>使用详细设计或源代码，画出程序流程图；</li><li>计算程序流程图的环路复杂性V(G) ；<ul><li>V(G) = 区域数量(由节点、连线包围的区域，包括图形外部区域)</li><li>V(G) = 连线数量 - 节点数量 + 2</li><li>V(G) = 简单可预测节点数量 + 1</li></ul></li><li>导出线性无关的基本程序路径集合；</li><li>为基本路径集合设置测试用例.</li></ol><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>主要用于功能测试阶段，也称黑盒测试为功能测试或数据驱动测试。检查系统功能是否按照需求规格说明书的规定正常使用、是否能适当接收输入数据输出正确的结果。</p><h5 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h5><p>等价类划分法是把所有可能的输入数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。</p><p>等价类是输入域的某个子集合，而所有等价类的并集就是整个输入域。因此，等价类对于测试有两个重要的意义：<br>完备性——整个输入域提供一种形式的完备性<br>无冗余性——若互不相交则可保证一种形式的无冗余性</p><p>等价类的分类：有效等价类和无效等价类。<br>设计测试用例时，要同时考虑这两种等价类。因为软件不仅要能接收合理的数据，也要能经受意外的考验。经过正反的测试才能确保软件具有更高的可靠性。</p><h6 id="有效等价类"><a href="#有效等价类" class="headerlink" title="有效等价类"></a>有效等价类</h6><p>是指对软件规格说明而言，是有意义的、合理的输入数据所组成的集合。利用有效等价类，能够检验程序是否实现了规格说明中预先规定的功能和性能。</p><h6 id="无效等价类"><a href="#无效等价类" class="headerlink" title="无效等价类"></a>无效等价类</h6><p>是指对软件规格说明而言，是无意义的、不合理的输入数据所构成的集合。利用无效等价类，可以鉴别程序异常处理的情况，检查被测对象的功能和性能的实现是否有不符合规格说明要求的地方。</p><h6 id="如何划分？"><a href="#如何划分？" class="headerlink" title="如何划分？"></a>如何划分？</h6><p>先从程序的规格说明书中找出各个输入条件，再为每个输入条件划分两个或多个等价类，形成若干的互不相交的子集。</p><h6 id="根据等价类创建测试用例的步骤"><a href="#根据等价类创建测试用例的步骤" class="headerlink" title="根据等价类创建测试用例的步骤"></a>根据等价类创建测试用例的步骤</h6><p>1、分析案例，建立等价类表，列出所有划分出的等价类：  </p><table><thead><tr><th style="text-align:center">条件</th><th style="text-align:center">有效等价类</th><th style="text-align:center">无效等价类</th></tr></thead><tbody><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>并为每个等价类规定一个唯一的编号。<br>2、设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的有效等价类。重复这个步骤，直到所有的有效等价类均被测试用例所覆盖。<br>3、设计一个新的测试用例，使它仅覆盖一个尚未覆盖的无效等价类。重复这一步骤，直到所有的无效等价类均被测试用例所覆盖。</p><h5 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h5><p>程序的很多错误发生在输入或输出范围的边界上，因此针对各种边界情况设置测试用例，可以发现不少程序缺陷；<br>通常边界值分析法是作为对等价类划分法的补充。这种情况下，其测试用例来自等价类的边界。  </p><h6 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h6><ul><li>首先确定边界情况。通常输入或输出等价类的边界就是应该着重测试的边界情况。</li><li>选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值。</li></ul><h5 id="判定表方法"><a href="#判定表方法" class="headerlink" title="判定表方法"></a>判定表方法</h5><p>等价类划分法和边界值法着重考虑输入条件，而忽略了输入条件的组合情况以及各种输入条件之间的相互制约关系。直接针对多种输入条件的组合，不需要考虑结果，即直接采用判定表方法。</p><p>判定表由“条件和活动”组成，条件是所有的条件组合，测试活动则考虑每一个选择；<br><em>涉及概念</em></p><ul><li>条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。</li><li>动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</li><li>条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。</li><li>动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。</li><li>规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。</li></ul><h6 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h6><ul><li>列出所有的条件桩和动作桩；</li><li>确定规则的个数（假如有n个条件。每个条件有两个取值（0,1）,故有2n种规则）；</li><li>填入条件项；</li><li>填入动作项，制定初始判定表；</li><li>简化、合并相似规则或相同动作。</li></ul><h5 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h5><p>如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p><p>因果图法的定义：是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p><p>多种输入条件的组合，产生多种结果设计测试用例。</p><h6 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h6><ul><li>分割功能说明书，识别“原因”和“结果”，并加以编号。</li><li>分析程序规格说明的描述中，哪些是原因，哪些是结果。原因常常是输入条件或是输入条件的等价类，而结果是输出条件。</li><li>根据原因与结果之间的关系画出因果图</li><li>标明约束条件</li><li>把因果图转换成判定表。</li><li>为判定表中每一列表示的情况设计测试用例。</li></ul><h5 id="正交试验法"><a href="#正交试验法" class="headerlink" title="正交试验法"></a>正交试验法</h5><ul><li>当输入条件多，且每个条件不能以“是”或“否”来回答，测试组合会很多，工作量也很大。  </li><li>利用因果图来设计测试用例时, 作为输入条件的原因与输出结果之间的因果关系,有时很难从软件需求 规格说明中得到。往往因果关系非常庞大,以至于据此因果图而得到的测试用例数目多的惊人，给软件测试 带来沉重的负担，</li></ul><h5 id="功能图法"><a href="#功能图法" class="headerlink" title="功能图法"></a>功能图法</h5><h5 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h5><h5 id="测试场景法"><a href="#测试场景法" class="headerlink" title="测试场景法"></a>测试场景法</h5><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试，也称组装测试、联合测试、子系统测试，在单元测试的基础上，将模块按照设计要求组装起来同时进行测试，主要目标是发现与接口有关的模块之间的问题。<br>两种集成方式：一次性集成方式和增殖式集成方式。</p><h3 id="一次性集成方式"><a href="#一次性集成方式" class="headerlink" title="一次性集成方式"></a>一次性集成方式</h3><h3 id="增殖式集成方式"><a href="#增殖式集成方式" class="headerlink" title="增殖式集成方式"></a>增殖式集成方式</h3><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试是将软件放在整个计算机环境下，包括软硬件平台、某些支持软件、数据和人员等，在实际运行环境下进行一系列的测试，包括恢复测试、安全测试、强度测试和性能测试等</p><h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><p>验收测试的目的是向未来的用户表明系统能够像预定要求那样工作，验证软件的功能和性能如同用户所合理期待的那样</p><p><img src="what_to_do.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软件测试定义&quot;&gt;&lt;a href=&quot;#软件测试定义&quot; class=&quot;headerlink&quot; title=&quot;软件测试定义&quot;&gt;&lt;/a&gt;软件测试定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1983 of IEEE Standard 729：&lt;br&gt;使用人工或自动手段来运行或者测试某个系统的过程&lt;br&gt;其目的在于检验它是否满足规定的需求或是弄清楚预期结果与实际结果之间的差别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件测试是&lt;strong&gt;验证&lt;/strong&gt;和&lt;strong&gt;有效性确认&lt;/strong&gt;构成的整体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“验证”是检验软件是否已正确地实现了产品规格书所定义的系统功能和特性&lt;/li&gt;
&lt;li&gt;“有效性确认”是确认所开发的软件是否满足用户真正需求的活动。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;下面关于软件测试，描述正确的是？(&lt;abcd&gt;)&lt;br&gt;A．软件测试是使用人工操作或者软件自动运行的方式来检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别的过程。&lt;br&gt;B．软件测试的测试目标是发现一些可以通过测试避免的开发风险。&lt;br&gt;C．软件测试的原则之一是测试应该尽早进行，最好在需求阶段就开始介入&lt;br&gt;D．软件测试主要工作内容是验证（verification）和确认（validation）&lt;/abcd&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="sofeware engineering" scheme="http://gitforhzc.github.io/categories/sofeware-engineering/"/>
    
    
      <category term="testing" scheme="http://gitforhzc.github.io/tags/testing/"/>
    
  </entry>
  
  <entry>
    <title>多进程编程</title>
    <link href="http://gitforhzc.github.io/2016/08/11/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://gitforhzc.github.io/2016/08/11/多进程编程/</id>
    <published>2016-08-11T00:17:46.000Z</published>
    <updated>2019-06-08T11:05:57.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>以哲学思想定制学习框架</strong></p><blockquote><p>唯物辩证法（Materialist Dialectics），是一种研究自然、社会、历史和思维的哲学方法。<em>此处为研究多进程编程</em><br>唯物辩证法试图回答的问题是“世界的存在状态问题”。世界存在的基本特征有两个：</p><ul><li>世界是普遍联系的<br>矛盾（即对立统一）是事物普遍联系的根本内容。<br>矛盾的双方总是“相比较而存在，相斗争而发展”的</li><li>世界是永恒发展的<br>所谓发展，是指事物由简单到复杂、由低级到高级的变化趋势<br>其实质是新事物的产生和旧事物的灭亡。  </li></ul></blockquote><a id="more"></a><h2 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h2><p><em>单线程与多线程的联系与发展</em></p><ul><li>单线程程序<br>一般来说，在没有线程的帮助下，程序在一个时间段只能执行一段代码，其它代码段只有在等待它完成后才能执行。该程序的处理流程从头到尾只有一条线，这样的程序我们称之为单线程程序（Single Thread Program）</li><li>多线程程序<br>当程序由一个以上的线程所构成时，称此程序为多线程程序（Multithread Program）<br>典型的多线程程序有：  <ul><li>GUI应用程序，Swing桌面程序就属于此类。</li><li>较花费时间的I/O处理,一般来说,文件和网络的输入/输出处理比较花费时间,如果在这段无法进行其它处理,则程序性能会大打折扣,遇到这种情况首先要想到用多线程解决问题.</li><li>多连接网络处理。</li></ul></li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p><em>并发与并行的联系与发展</em></p><ul><li>并发<br>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent).</li><li>并行<br>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)<br><img src="concurrentparalel.jpg" alt></li></ul><h2 id="多线程在并发和并行环境中的作用"><a href="#多线程在并发和并行环境中的作用" class="headerlink" title="多线程在并发和并行环境中的作用"></a>多线程在并发和并行环境中的作用</h2><p><em>多线程在并发和并行环境中的联系与发展</em></p><ul><li>在并发环境时,多线程不可能真正充分利用CPU,节约运行时间,它只是以”挂起-&gt;执行-&gt;挂起”的方式以很小的时间片分别运行各个线程,给用户以每个线程都在运行的错觉.在这种环境中,多线程程序真正改善的是系统的响应性能和程序的友好性.</li><li>在并行环境中, 一个时刻允许多个线程运行,这时多线程程序才真正充分利用了多CPU的处理能力, 节省了整体的运行时间.在这种环境中,多线程程序能体现出它的四大优势:充分利用CPU,节省时间,改善响应和增加程序的友好性.</li></ul><hr><h1 id="多进程编程理论"><a href="#多进程编程理论" class="headerlink" title="多进程编程理论"></a>多进程编程理论</h1><p>多进程编程的主要内容是进程控制和进程通信。  </p><blockquote><p>唯物辩证法的五对基本范畴是:<br>现象和本质、内容和形式、原因和结果、可能性和现实性、偶然性和必然性。<br>除了上述五个基本辩证范畴，比较重要的辩证范畴还有:<br>整体和部分，个性和共性，相对和绝对，等等。</p></blockquote><p><em>并发与进程的因果</em><br>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。<br>为此引入了进程(Process)的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><p><em>进程的形式</em><br>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p><em>进程的内容</em><br>进程一般由程序、数据集合和进程控制块三部分组成。</p><ul><li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li><li>数据集合是程序在执行时所需要的数据和工作区；</li><li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li></ul><p><em>进程的个性</em><br>进程是操作系统的资源分配和独立运行的基本单位。它一般由以下三个部分组成。  </p><ul><li>程序段<br>程序段就是能被进程调度程序调度到CPU执行的程序代码段。<br>注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序。  </li><li>数据段<br>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</li><li>进程控制块<br>进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任一时刻可以存取, 在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。  <ul><li>当创建一个进程时，系统为该进程建立一个PCB；  </li><li>当进程执行时，系统通过其PCB了解进程的现行状态信息，以便对其进行控制和管理；</li><li>当进程结束时，系统收回其PCB,该进程随之消亡。    </li></ul></li></ul><p><em>进程的共性</em><br>进程具有的特征：</p><ul><li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li><li>并发性：任何进程都可以同其他进程一起并发执行；</li><li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li><li>结构性：进程由程序、数据和进程控制块三部分组成。</li></ul><h3 id="进程控制块-PCB-详情"><a href="#进程控制块-PCB-详情" class="headerlink" title="进程控制块(PCB)详情"></a>进程控制块(PCB)详情</h3><p>操作系统通过PCB表来管理和控制进程。<br>PCB通常包含的内容如图：<br><img src="PCB.png" alt><br>上图是一个PCB的实例，PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下：  </p><ul><li>进程描述信息  <ul><li>进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号。</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。</li></ul></li><li>进程控制和管理信息<ul><li>进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。</li><li>进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。</li></ul></li><li>资源分配清单<br>用于说明有关内存地址空间或虚拟地址空间的状况；所打开文件的 列表和所使用的输入/输出设备信息。</li><li>处理机相关信息<br>主要指处理机中各寄存器值，当进程被切换时，处理机状态信息 都必须保存在相应的PCB中，以便在该进程重新执行时，能再从断点继续执行。</li></ul><p>在一个系统中，通常存在着许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。<br>目前，常用的组织方式有链接方式和索引方式两种。  </p><ul><li>链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。</li><li>索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。   </p><blockquote><p>唯物辩证法认为：可能性和现实性是揭示客观事物由可能向现实转化过程的一对范畴。可能性指事物包含的种种可能的发展趋势，现实性指已经实现了的可能性，即实际存在的事物和过程。<br>由于事物内部矛盾和外部矛盾的复杂性，事物往往包含相互矛盾的几种可能性。但是只有一种可能性在内外条件齐备的情况下转化为现实，其他的可能性在矛盾的斗争中被克服而没有成为现实。</p></blockquote><p><em>进程的现实性：创建、运行、结束</em><br><em>进程的可能性：运行、就绪、阻塞状态</em></p><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>创建状态<br>操作系统在创建进程时要进行的工作包括：<br>分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；</p><h4 id="结束过程"><a href="#结束过程" class="headerlink" title="结束过程"></a>结束过程</h4><p>结束状态<br>进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。</p><h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><ul><li>运行状态<br>进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。  </li><li>就绪状态<br>进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。以下三种情况进入就绪状态：<ul><li>创建状态 -&gt; 就绪状态：进程创建之后，等待处理器运行</li><li>运行状态 -&gt; 就绪状态：时间片已用完，此进程被强制暂停，等待下一个属于它的时间片到来；</li><li>阻塞状态 -&gt; 就绪状态：等待的事件到来时，如I/O操作完成；  </li></ul></li><li>阻塞状态<br>进程需要其他资源（除了处理机）或等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。  </li></ul><p>下图说明了五种进程状态的转换：<br><img src="process_status.png" alt></p><h3 id="进程控制的详情"><a href="#进程控制的详情" class="headerlink" title="进程控制的详情"></a>进程控制的详情</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、终止已有进程、实现进程状态转换等功能。<br>在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。实现方式有两种：</p><ul><li>通常可由硬件来实现完成不被分割执行特性的功能</li><li>在单处理机时可由软件通过屏蔽中断方法实现不被中断执行特性。</li></ul><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。<br>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。<br>操作系统创建一个新进程的过程如下（创建原语)：</p><ul><li>为新进程分配一个唯一的进程标识号PID，并申请一个空白的PCB(PCB是有限的)。若PCB申请失败则创建失败。</li><li>为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在PCB 中体现）。</li><li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。</li></ul><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>引起进程终止的事件主要有：</p><ul><li>正常结束，表示进程的任务已经完成和准备退出运行。</li><li>异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。</li><li>外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</li></ul><p>操作系统终止进程的过程如下（撤销原语）：</p><ul><li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态。</li><li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子进程，则应将其所有子进程终止。</li><li>将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ul><h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。<br>可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p><h5 id="阻塞原语"><a href="#阻塞原语" class="headerlink" title="阻塞原语"></a>阻塞原语</h5><p>阻塞原语的执行过程是：  </p><ul><li>找到将要被阻塞进程的标识号对应的PCB。</li><li>若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。</li><li>把该PCB插入到相应事件的等待队列中去。</li></ul><p>当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。</p><h5 id="唤醒原语"><a href="#唤醒原语" class="headerlink" title="唤醒原语"></a>唤醒原语</h5><p>唤醒原语的执行过程是：</p><ul><li>在该事件的等待队列中找到相应进程的PCB。</li><li>将其从等待队列中移出，并置其状态为就绪状态。</li><li>把该PCB插入就绪队列中，等待调度程序调度。</li></ul><p>需要注意的是，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。 Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。</p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。<br>进程切换的过程如下：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ul><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。</p><blockquote><p>唯物辩证法认为：联系具有客观性、普遍性、和多样性。  </p><ul><li>联系的客观性：联系是事物本身所固有、不以人的主观意志为转移的。  </li><li>联系的普遍性：一切事物、现象和过程，及其内部各要素、部分、环节，都不是孤立存在的，它们相互依赖、相互作用、相互影响、相互制约。但另一方面事物又存在着相对独立性，即任何事物都同其他事物相区别而相对独立地存在。  </li><li>联系的多样性：从大的方面说，联系可分为内部联系和外部联系、本质联系和非本质联系、必然联系和偶然联系、主要联系和次要联系、直接联系和间接联系，等等。</li></ul></blockquote><p><em>进程之间的联系：通信</em>  </p><h3 id="低级通信方式"><a href="#低级通信方式" class="headerlink" title="低级通信方式"></a>低级通信方式</h3><p>信号量的PV操作，详见<a href="#信号量机制实现进程同步互斥">信号量机制实现进程同步互斥</a></p><h3 id="高级通信方式"><a href="#高级通信方式" class="headerlink" title="高级通信方式"></a>高级通信方式</h3><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>在通信的进程之间存在一块可直接访问的共享空间()，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。(详见<a href="#进程间的相互制约关系">进程间的相互制约关系</a>)</p><p>共享内存又分为两种：</p><ul><li>低级方式的共享是基于数据结构的共享；</li><li>高级方式则是基于内存区的共享。  </li></ul><p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p><p>需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>在消息队列系统中，进程间的数据交换是以格式化的消息(Message)为单位的。<br>进程通过系统提供的发送消息和接收消息两个原语进行数据交换。  </p><ul><li>直接通信方式<br>发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li><li>间接通信方式<br>发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。<br>这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。<br>该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p>管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。  </p><ul><li>发送进程（即写进程）向管道提供输入，以字符流形式将大量的数据送入（写）管道（共享文件）；</li><li>接收进程（即读进程）从管道中接收（读）数据。</li></ul><p>为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p><hr><h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><p><em>进程并发与进程同步的因果</em><br>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。操作系统实现进程同步互斥的机制称为同步机制。</p><h4 id="进程间的相互制约关系"><a href="#进程间的相互制约关系" class="headerlink" title="进程间的相互制约关系"></a>进程间的相互制约关系</h4><h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。<br>为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：</p><ul><li>进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li><li>临界区。进程中访问临界资源的那段代码，又称临界段。</li><li>退出区。将正在访问临界区的标志清除。</li><li>剩余区。代码中的其余部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    entry section;  //进入区</span><br><span class="line">    critical section;  //临界区</span><br><span class="line">    exit section;  //退出区</span><br><span class="line">    remainder section;  //剩余区</span><br><span class="line">&#125; while (true)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>唯物辩证法认为：矛盾（即对立统一）是事物普遍联系的根本内容。<br>所谓矛盾，在辩证法中是指“事物内部或事物之间的对立统一的辩证关系”；<br>矛盾的双方总是“相比较而存在，相斗争而发展”的。  </p><ul><li>矛盾的同一性和斗争性<br>唯物辩证法认为：同一性和斗争性是矛盾的两种基本属性。  <ul><li>同一性是指矛盾双方相互依存，相互联系、相互吸引、相互贯通、或相互渗透的性质和趋势</li><li>斗争性是指矛盾双方相互排斥、相互限制、相互否定、相互分离、或互相批评的性质和趋势；</li></ul></li><li>矛盾的普遍性和特殊性<br>唯物辩证法认为：<ul><li>矛盾的普遍性是指矛盾存在于一切事物的发展过程中，每一事物的发展过程中自始至终存在着矛盾运动。</li><li>矛盾的特殊性是指具体事物的矛盾及每一矛盾的各个方面都有其特点，这是一事物区别于他事物的本质，是世界上事物之所以有差别的根据。</li></ul></li></ul></blockquote><p><em>进程间的矛盾：同步和互斥</em></p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。<br>进程间的直接制约关系就是源于它们之间的相互合作。</p><p>例如，输入进程A通过单缓冲向进程B提供数据。  </p><ul><li>当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。  </li><li>当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</li></ul><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。</p><h4 id="实现临界区互斥的方法"><a href="#实现临界区互斥的方法" class="headerlink" title="实现临界区互斥的方法"></a>实现临界区互斥的方法</h4><p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：  </p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><h5 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h5><p>在进入区设置和检查一些标志来标明是否有进程在临界区中，如果已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p><h6 id="单标志法-测试版"><a href="#单标志法-测试版" class="headerlink" title="单标志法(测试版)"></a>单标志法(测试版)</h6><p>该算法设置一个公用整型变量turn,用于指示被允许进入临界区的进程编号，即若turn=0，则允许P0进程进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，如果某个进程不再进入临界区了，那么另一个进程也将进入临界区（违背“空闲让进”）这样很容易造成资源利用的不充分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// P0进程</span><br><span class="line">while(turn!=0);</span><br><span class="line">critical section;</span><br><span class="line">turn=1;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// P1进程</span><br><span class="line">while(turn!=1);  // 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">turn = 0;  // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><h6 id="双标志法先检查-测试版"><a href="#双标志法先检查-测试版" class="headerlink" title="双标志法先检查(测试版)"></a>双标志法先检查(测试版)</h6><p>该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置了一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pi 进程</span><br><span class="line">while(flag[j]);  // ①    </span><br><span class="line">flag[i]=TRUE;  // ③  </span><br><span class="line">critical section;   </span><br><span class="line">flag[i] = FALSE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pj 进程</span><br><span class="line">while(flag[i]);  // ② 进入区</span><br><span class="line">flag[j] =TRUE;  // ④ 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">flag[j] = FALSE;  // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><p>优点：不用交替进入，可连续使用；<br>缺点：Pi和Pj可能同时进入临界区。按序列①②③④ 执行时，会同时进入临界区（违背“忙则等待”)。即在检查对方flag之后和切换自己flag 之前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</p><h6 id="双标志法后检查-测试版"><a href="#双标志法后检查-测试版" class="headerlink" title="双标志法后检查(测试版)"></a>双标志法后检查(测试版)</h6><p>“双标志法先检查”是先检测对方进程状态标志后，再置自己标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后，同时进入临界区。<br>为此，“双标志法后检查”釆用先设置自己标志为TRUE后,再检测对方状态标志，若对方标志为TURE，则进程等待；否则进入临界区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pi进程</span><br><span class="line">flag[i] =TRUE;</span><br><span class="line">while(flag[j]);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] =FLASE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pj进程</span><br><span class="line">flag[j] =TRUE;  // 进入区</span><br><span class="line">while(flag[i]);  // 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">flag [j] =FLASE;   // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><p>当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。(详见<a href="#进程死锁">进程死锁</a>)</p><h6 id="Peterson’s-Algorithm-正式版"><a href="#Peterson’s-Algorithm-正式版" class="headerlink" title="Peterson’s Algorithm(正式版)"></a>Peterson’s Algorithm(正式版)</h6><p>flag[n]的值为真，表示ID号为n的进程希望进入该临界区. 变量turn保存有权访问共享资源的进程的ID号.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//flag[] is boolean array; and turn is an integer</span><br><span class="line">flag[i]   = false;</span><br><span class="line">flag[j]   = false;</span><br><span class="line">int turn;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pi进程</span><br><span class="line">flag[i]=TURE; turn=j;</span><br><span class="line">while(flag[j]&amp;&amp;turn==j);</span><br><span class="line">critical section;</span><br><span class="line">flag[i]=FLASE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Pj进程</span><br><span class="line">flag[j] =TRUE;turn=i;  // 进入区</span><br><span class="line">while(flag[i]&amp;&amp;turn==i);   // 进入区</span><br><span class="line">critical section;  // 临界区</span><br><span class="line">flag[j]=FLASE;  // 退出区</span><br><span class="line">remainder section;  // 剩余区</span><br></pre></td></tr></table></figure><p>本算法的基本思想是“单标志法”和“双标志法后检查”的结合。利用flag解决临界资源的互斥访问，而利用turn解决“饥饿”现象。</p><h5 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h5><p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。通过硬件支持实现临界段问题的低级方法或称为元方法。</p><h6 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h6><p>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。<br>因为CPU只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。其典型模式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">…  </span><br><span class="line">关中断;  </span><br><span class="line">临界区;  </span><br><span class="line">开中断;  </span><br><span class="line">…</span><br></pre></td></tr></table></figure></p><p>这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。</p><h6 id="硬件指令方法"><a href="#硬件指令方法" class="headerlink" title="硬件指令方法"></a>硬件指令方法</h6><ul><li><p>TestAndSet指令<br>TestAndSet指令：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。指令的功能描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean TestAndSet(boolean *lock)&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock=true;</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正被占用，初值为false。在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，直到进程退出。利用该指令实现进程互斥的算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (TestAndSet (&amp; lock));</span><br><span class="line">// 进程的临界区代码段;</span><br><span class="line">lock=false;</span><br><span class="line">// 进程的其他代码</span><br></pre></td></tr></table></figure></li><li><p>Swap指令<br>Swap指令：该指令的功能是交换两个字节的内容。其功能描述如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Swap(boolean *a, boolean *b)&#123;  </span><br><span class="line">    boolean temp;</span><br><span class="line">    Temp=*a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应为每个临界资源设置了一个共享布尔变量lock，初值为false；在每个进程中再设置一个局部布尔变量key，用于与lock交换信息。在进入临界区之前先利用Swap指令交换lock 与key的内容，然后检查key的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。利用Swap指令实现进程互斥的算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key=true;</span><br><span class="line">while(key!=false)</span><br><span class="line">  Swap(&amp;lock, &amp;key);</span><br><span class="line">// 进程的临界区代码段；</span><br><span class="line">lock=false;</span><br><span class="line">// 进程的其他代码；</span><br></pre></td></tr></table></figure><p>优点：适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。<br>缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。</p></li></ul><p>注意：以上对TestAndSet和Swap指令的描述仅仅是功能实现，并非软件实现定义，事实上它们是由硬件逻辑直接实现的，不会被中断。</p><h4 id="信号量机制实现进程同步互斥"><a href="#信号量机制实现进程同步互斥" class="headerlink" title="信号量机制实现进程同步互斥"></a>信号量机制实现进程同步互斥</h4><p>信号量机制是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”和“V操作”。</p><p>原语之所以不能被中断执行，是因为原语对变量的操作过程如果被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><h6 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h6><p>整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    while (S&lt;=0);</span><br><span class="line">    S=S-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S=S+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait操作中，只要信号量S&lt;=0，就会不断地测试。因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态。</p><h6 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h6><p>记录型信号量是不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程，记录型信号量是由于釆用了记录型的数据结构得名。记录型信号量可描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct process *L;</span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></p><p>相应的wait(S)和signal(S)的操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void wait (semaphore S) &#123; //相当于申请资源</span><br><span class="line">    S.value--;</span><br><span class="line">    if(S.value&lt;0) &#123;</span><br><span class="line">        add this process to S.L;</span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>wait操作，S.value--，表示进程请求一个该类资源，当S.value&lt;0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void signal (semaphore S) &#123;  //相当于释放资源</span><br><span class="line">    S.value++;</span><br><span class="line">    if(S.value&lt;=0)&#123;</span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value&lt;=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup 原语，将S.L中的第一个等待进程唤醒。</p><h5 id="利用信号量实现进程同步"><a href="#利用信号量实现进程同步" class="headerlink" title="利用信号量实现进程同步"></a>利用信号量实现进程同步</h5><p>信号量机制能用于解决进程间各种同步问题。设S为实现进程P1、P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所以只有当语句x执行完成之后语句y才可以执行。其实现进程同步的算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = 0;  //初始化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    // …</span><br><span class="line">    x;  //语句x</span><br><span class="line">    V(S);  //告诉进程P2,语句乂已经完成</span><br><span class="line">&#125;</span><br><span class="line">P2()）&#123;</span><br><span class="line">    // …</span><br><span class="line">    P(S) ;  //检查语句x是否运行完成</span><br><span class="line">    y;  // 检查无误，运行y语句</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="利用信号量实现进程互斥"><a href="#利用信号量实现进程互斥" class="headerlink" title="利用信号量实现进程互斥"></a>利用信号量实现进程互斥</h5><p>信号量机制也能很方便地解决进程互斥问题。设S为实现进程P1、P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值应为1（即可用资源数为1)。只需把临界区置于P(S)和V(S)之间，即可实现两进程对临界资源的互斥访问。其算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = 1;  //初化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    // …</span><br><span class="line">    P(S);  // 准备开始访问临界资源，加锁</span><br><span class="line">    // 进程P1的临界区</span><br><span class="line">    V(S);  // 访问结束，解锁</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    // …</span><br><span class="line">    P(S); //准备开始访问临界资源，加锁</span><br><span class="line">    // 进程P2的临界区；</span><br><span class="line">    V(S);  // 访问结束，解锁</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>互斥的实现是不同进程对同一信号量进行P、V操作，一个进程在成功地对信号量执行了P操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行V操作,表示当前没有进程进入临界区，可以让其他进程进入。</p><h5 id="利用信号量实现前驱关系"><a href="#利用信号量实现前驱关系" class="headerlink" title="利用信号量实现前驱关系"></a>利用信号量实现前驱关系</h5><p>信号量也可以用来描述程序之间或者语句之间的前驱关系。图2-8给出了一个前驱图，其中S1, S2, S3, …, S6是最简单的程序段（只有一条语句）。为使各程序段能正确执行，应设置若干个初始值为“0”的信号量。例如，为保证S1 -&gt; S2、 S1 -&gt; S3的前驱关系，应分别设置信号量a1、a2。同样，为了保证 S2 -&gt; S4、S2 -&gt;S5、S3 -&gt; S6、S4 -&gt; S6、S5 -&gt; S6,应设置信号量bl、b2、c、d、e。<br><img src="precursor.png" alt><br>实现算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore  al=a2=bl=b2=c=d=e=0;  //初始化信号量</span><br><span class="line">S1() &#123;</span><br><span class="line">    // …</span><br><span class="line">    V(al);  V(a2) ;  //S1已经运行完成</span><br><span class="line">&#125;</span><br><span class="line">S2() &#123;</span><br><span class="line">    P(a1);  //检查S1是否运行完成</span><br><span class="line">    // …</span><br><span class="line">    V(bl); V(b2); // S2已经运行完成</span><br><span class="line">&#125;</span><br><span class="line">S3() &#123;</span><br><span class="line">    P(a2);  //检查S1是否已经运行完成</span><br><span class="line">    // …</span><br><span class="line">    V(c);  //S3已经运行完成</span><br><span class="line">&#125;</span><br><span class="line">S4() &#123;</span><br><span class="line">    P(b1);  //检查S2是否已经运行完成</span><br><span class="line">    // …</span><br><span class="line">    V(d);  //S4已经运行完成</span><br><span class="line">&#125;</span><br><span class="line">S5() &#123;</span><br><span class="line">    P(b2);  //检查S2是否已经运行完成</span><br><span class="line">    // …</span><br><span class="line">    V(e);  // S5已经运行完成</span><br><span class="line">&#125;</span><br><span class="line">S6() &#123;</span><br><span class="line">    P(c);  //检查S3是否已经运行完成</span><br><span class="line">    P(d);  //检查S4是否已经运行完成</span><br><span class="line">    P(e);  //检查S5是否已经运行完成</span><br><span class="line">    // …;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h4><p>分析进程同步和互斥问题的方法：  </p><ul><li>关系分析。找出问题中的进程数，并且分析它们之间的同步和互斥关系。同步、互斥、前驱关系直接按照上面例子中的经典范式改写。  </li><li>整理思路。找出解决问题的关键点，并且根据进程的操作流程确定P操作、V操作的大致顺序。  </li><li>设置信号量。根据上面两步，设置需要的信号量，确定初值，完善整理。</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p><h6 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h6><ul><li>关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</li><li>整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。</li><li>信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</li></ul><p>生产者-消费者进程的描述如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=1; //临界区互斥信号量</span><br><span class="line">semaphore empty=n;  //空闲缓冲区</span><br><span class="line">semaphore full=0;  //缓冲区初始化为空</span><br><span class="line">producer () &#123; //生产者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        produce an item in nextp;  //生产数据</span><br><span class="line">        P(empty);  //获取空缓冲区单元</span><br><span class="line">        P(mutex);  //进入临界区.</span><br><span class="line">        add nextp to buffer;  //将数据放入缓冲区</span><br><span class="line">        V(mutex);  //离开临界区,释放互斥信号量</span><br><span class="line">        V(full);  //满缓冲区数加1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer () &#123;  //消费者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);  //获取满缓冲区单元</span><br><span class="line">        P(mutex);  // 进入临界区</span><br><span class="line">        remove an item from buffer;  //从缓冲区中取出数据</span><br><span class="line">        V (mutex);  //离开临界区，释放互斥信号量</span><br><span class="line">        V (empty) ;  //空缓冲区数加1</span><br><span class="line">        consume the item;  //消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该类问题要注意对缓冲区大小为n的处理，当缓冲区中有空时便可对empty变量执行P 操作，一旦取走一个产品便要执行V操作以释放空闲区。对empty和full变量的P操作必须放在对mutex的P操作之前。如果生产者进程先执行P(mutex)，然后执行P(empty)，消费者执行P(mutex),然后执行P(fall),这样可不可以？答案是否定的。设想生产者进程已经将缓冲区放满，消费者进程并没有取产品，即empty = 0，当下次仍然是生产者进程运行时，它先执行P(mutex)封锁信号量，再执行P(empty)时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行P(mutex)，然而由于生产者进程已经封锁mutex信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，陷入了无休止的等待。同理，如果消费者进程已经将缓冲区取空，即 full = 0,下次如果还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex、full先释放哪一个无所谓，消费者先释放mutex还是empty都可以。  </p><p>下面再看一个较为复杂的生产者-消费者问题:</p><h6 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h6><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈就可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿<br>可以从盘子中取出。</p><h6 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h6><ul><li>关系分析。这里的关系稍复杂一些，首先由每次只能向其中放入一只水果可知爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发，如图2-8所示。</li><li>整理思路。这里有4个进程，实际上可以抽象为两个生产者和两个消费者被连接到大小为1的缓冲区上。<br><img src="producer_consumer.png" alt></li><li>信号量设置。首先设置信号量plate为互斥信号量，表示是否允许向盘子放入水果，初值为1，表示允许放入，且只允许放入一个。信号量 apple表示盘子中是否有苹果，初值为0，表示盘子为空，不许取，若apple=l可以取。信号量orange表示盘子中是否有橘子，初值为0，表示盘子为空，不许取，若orange=l可以取。  </li></ul><p>解决该问题的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate=l, apple=0, orange=0;</span><br><span class="line">dad() &#123;  //父亲进程</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        prepare an apple;</span><br><span class="line">        P(plate) ;  //互斥向盘中取、放水果</span><br><span class="line">        put the apple on the plate;  //向盘中放苹果</span><br><span class="line">        V(apple);  //允许取苹果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom() &#123;  // 母亲进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        prepare an orange;</span><br><span class="line">        P(plate);  //互斥向盘中取、放水果</span><br><span class="line">        put the orange on the plate;  //向盘中放橘子</span><br><span class="line">        V(orange); //允许取橘子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son()&#123;  //儿子进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(orange) ;  //互斥向盘中取橘子</span><br><span class="line">        take an orange from the plate;</span><br><span class="line">        V(plate);  //允许向盘中取、放水果</span><br><span class="line">        eat the orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter () &#123;  //女儿进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(apple);  // 互斥向盘中取苹果</span><br><span class="line">        take an apple from the plate;</span><br><span class="line">        V(plate);  //运行向盘中取、放水果</span><br><span class="line">        eat the apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进程间的关系如图2-9所示。dad()和daughter()、mam()和son()必须连续执行，正因为如此，也只能在女儿拿走苹果后，或儿子拿走橘子后才能释放盘子，即V(plate)操作。</p><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><h6 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h6><p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<br>因此要求：</p><ul><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ul><h6 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h6><ul><li>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</li><li>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。</li><li>信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。</li></ul><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int count=0;  //用于记录当前的读者数量</span><br><span class="line">semaphore mutex=1;  //用于保护更新count变量时的互斥</span><br><span class="line">semaphore rw=1;  //用于保证读者和写者互斥地访问文件</span><br><span class="line">writer () &#123;  //写者进程</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        P(rw); // 互斥访问共享文件</span><br><span class="line">        Writing;  //写入</span><br><span class="line">        V(rw) ;  //释放共享文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader () &#123;  // 读者进程</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P (mutex) ;  //互斥访问count变量</span><br><span class="line">        if (count==0)  //当第一个读进程读共享文件时</span><br><span class="line">            P(rw);  //阻止写进程写</span><br><span class="line">        count++;  //读者计数器加1</span><br><span class="line">        V (mutex) ;  //释放互斥变量count</span><br><span class="line">        reading;  //读取</span><br><span class="line">        P (mutex) ;  //互斥访问count变量</span><br><span class="line">        count--; //读者计数器减1</span><br><span class="line">        if (count==0)  //当最后一个读进程读完共享文件</span><br><span class="line">            V(rw) ;  //允许写进程写</span><br><span class="line">        V (mutex) ;  //释放互斥变量 count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的算法中，读进程是优先的，也就是说，当存在读进程时，写操作将被延迟，并且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式下，会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</p><p>如果希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等待到已在共享文件的读进程执行完毕则立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并且在上面的程序中 writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int count = 0;  //用于记录当前的读者数量</span><br><span class="line">semaphore mutex = 1;  //用于保护更新count变量时的互斥</span><br><span class="line">semaphore rw=1;  //用于保证读者和写者互斥地访问文件</span><br><span class="line">semaphore w=1;  //用于实现“写优先”</span><br><span class="line">writer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(w);  //在无写进程请求时进入</span><br><span class="line">        P(rw);  //互斥访问共享文件</span><br><span class="line">        writing;  //写入</span><br><span class="line">        V(rw);  // 释放共享文件</span><br><span class="line">        V(w) ;  //恢复对共享支件的访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader () &#123;  //读者进程</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        P (w) ;  // 在无写进程请求时进入</span><br><span class="line">        P (mutex);  // 互斥访问count变量</span><br><span class="line">        if (count==0)  //当第一个读进程读共享文件时</span><br><span class="line">            P(rw);  //阻止写进程写</span><br><span class="line">        count++;  //读者计数器加1</span><br><span class="line">        V (mutex) ;  //释放互斥变量count</span><br><span class="line">        V(w);  //恢复对共享文件的访问</span><br><span class="line">        reading;  //读取</span><br><span class="line">        P (mutex) ; //互斥访问count变量</span><br><span class="line">        count--;  //读者计数器减1</span><br><span class="line">        if (count==0)  //当最后一个读进程读完共享文件</span><br><span class="line">            V(rw);  //允许写进程写</span><br><span class="line">        V (mutex);  //释放互斥变量count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><h6 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h6><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><h6 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h6><ul><li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。<br><img src="philosopher dinner.png" alt></li><li>信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {l, 1, 1, 1, 1}用于对5个筷子的互斥访问。</li></ul><p>对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;; //定义信号量数组chopstick[5],并初始化</span><br><span class="line">Pi()&#123;  //i号哲学家的进程</span><br><span class="line">    do&#123;</span><br><span class="line">        P (chopstick[i] ) ; //取左边筷子</span><br><span class="line">        P (chopstick[(i+1) %5] ) ；  //取右边篌子</span><br><span class="line">        eat;  //进餐</span><br><span class="line">        V(chopstick[i]) ; //放回左边筷子</span><br><span class="line">        V(chopstick[(i+l)%5]);  //放回右边筷子</span><br><span class="line">        think;  //思考</span><br><span class="line">    &#125; while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该算法存在以下问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完wait(chopstick[i]);)筷子已经被拿光了，等到他们再想拿右边的筷子的时候（执行 wait(chopstick[(i+l)%5]);)就全被阻塞了，这就出现了死锁。</p><p>为了防止死锁的发生，可以对哲学家进程施加一些限制条件，比如至多允许四个哲学家同时进餐;仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子;对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再转他右边的筷子，而偶数号哲学家刚好相反。正解制定规则如下：假设釆用第二种方法，当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1,1,1,1,1&#125;; //初始化信号量</span><br><span class="line">semaphore mutex=l;  //设置取筷子的信号量</span><br><span class="line">Pi()&#123; //i号哲学家的进程</span><br><span class="line">    do&#123;</span><br><span class="line">        P (mutex) ; //在取筷子前获得互斥量</span><br><span class="line">        P (chopstick [i]) ; //取左边筷子</span><br><span class="line">        P (chopstick[ (i+1) %5]) ;  //取右边筷子</span><br><span class="line">        V (mutex) ; //释放取筷子的信号量</span><br><span class="line">        eat;  //进餐</span><br><span class="line">        V(chopstick[i] ) ;  //放回左边筷子</span><br><span class="line">        V(chopstick[ (i+l)%5]) ;  //放回右边筷子</span><br><span class="line">        think;  // 思考</span><br><span class="line">    &#125;while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外还可以釆用AND型信号量机制来解决哲学家进餐问题，有兴趣的读者可以查阅相关资料，自行思考。</p><h5 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h5><h6 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h6><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟 并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟 者中，第一个拥有烟草、第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料， 供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供 应者一个信号告诉完成了，供应者就会放另外两种材料在桌上，这种过程一直重复（让三个 抽烟者轮流地抽烟)。</p><h6 id="问题分析-4"><a href="#问题分析-4" class="headerlink" title="问题分析"></a>问题分析</h6><ul><li>关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知</li><li>整理思路。显然这里有四个进程。供应者作为生产者向三个抽烟者提供材料。</li><li>信号量设置。信号量offer1、offer2、offer3分别表示烟草和纸组合的资源、烟草和 胶水组合的资源、纸和胶水组合的资源。信号量finish用于互斥进行抽烟动作。</li></ul><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int random; //存储随机数</span><br><span class="line">semaphore offer1=0; //定义信号量对应烟草和纸组合的资源</span><br><span class="line">semaphore offer2=0; //定义信号量对应烟草和胶水组合的资源</span><br><span class="line">semaphore offer3=0; //定义信号量对应纸和胶水组合的资源</span><br><span class="line">semaphore finish=0; //定义信号量表示抽烟是否完成</span><br><span class="line"></span><br><span class="line">//供应者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    random = 任意一个整数随机数;</span><br><span class="line">    random=random% 3;</span><br><span class="line">    if(random==0)</span><br><span class="line">        V(offerl) ; //提供烟草和纸</span><br><span class="line">    else if(random==l)</span><br><span class="line">        V(offer2);  //提供烟草和胶水</span><br><span class="line">    else</span><br><span class="line">        V(offer3)  //提供纸和胶水</span><br><span class="line">    // 任意两种材料放在桌子上;</span><br><span class="line">    P(finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拥有烟草者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    P (offer3);</span><br><span class="line">    // 拿纸和胶水，卷成烟，抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拥有纸者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    P(offer2);</span><br><span class="line">    // 烟草和胶水,卷成烟，抽掉；</span><br><span class="line">    V(finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拥有胶水者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    P(offer1);</span><br><span class="line">    // 拿烟草和纸，卷成烟，抽掉;</span><br><span class="line">    v(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><h4 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h4><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。<br>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>下面我们通过一些实例来说明死锁现象。  </p><ul><li>先看生活中的一个实例，在一条河上有一座桥，桥面很窄，只能容纳一辆汽车通行。如果有两辆汽车分别从桥的左右两端驶上该桥，则会出现下述的冲突情况。此时，左边的汽车占有了桥面左边的一段，要想过桥还需等待右边的汽车让出桥面右边的一段；右边的汽车占有了桥面右边的一段，要想过桥还需等待左边的汽车让出桥面左边的一段。此时，若左右两边的汽车都只能向前行驶，则两辆汽车都无法过桥。</li><li>在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</li></ul><h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><ul><li>系统资源的竞争<br>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。  </li><li>进程推进顺序非法<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。</li><li>信号量使用不当<br>进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</li></ul><h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</li></ul><p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。</p><p>Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。<br><img src="deadlock_circur.png" alt></p><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。</p><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><p>预防死锁和避免死锁都属于事先预防策略</p><ul><li>预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；  </li><li>避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</li></ul><p>检测及解除死锁无需釆取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后釆取某种措施解除死锁。</p><p>死锁的几种处理策略的比较见表2-14。<br><img src="lock_compare.png" alt></p><h5 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h5><p>设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁。<br>防止死锁的发生只需破坏死锁产生的四个必要条件之一即可。</p><ul><li><p>破坏互斥条件<br>如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p></li><li><p>破坏不剥夺条件<br>当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。<br>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p></li><li><p>破坏请求和保持条件<br>釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。<br>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p></li><li><p>破坏循环等待条件<br>为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。<br>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使甩资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。</p></li></ul><h5 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h5><p>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。  </p><h6 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h6><p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。<br>所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, …, Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, …, Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见表2-15。<br><img src="resource_alloc.png" alt><br>则在T0时刻是安全的，因为存在一个安全序列P2、P1、P3，即只要系统按此进程序列分配资源，则每个进程都能顺利完成。若在T0时刻后，系统分配1台磁带机给P3，则此时系统便进入不安全状态，因为此时已无法再找到一个安全序列。<br>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p><h6 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h6><p>银行家算法是最著名的死锁避免算法。<br>它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。<br>操作系统按照银行家制定的规则为进程分配资源  </p><ul><li>当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</li><li>当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li></ul><p><strong>数据结构描述</strong></p><ul><li>可利用资源矢量Available：含有m个元素的歎组，其中的每一个元素代表一类可用的资源数目。Available[j]=K，则表示系统中现有Rj类资源K个。</li><li>最大需求矩阵Max：为n*m矩阵，定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K。</li><li>分配矩阵Allocation：为n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。All0Cati0n[i, j]= K，则表示进程i当前已分得Rj类资源的数目为K。</li><li>需求矩阵Need：为n*m矩阵，表示每个进程尚需的各类资源数。Need[i, j]=K，则表示进程i还需要Rj类资源的数目为K。</li></ul><p>上述三个矩阵间存在下述关系：<br>Need[i, j] = Max[i, j] - Allocation[i, j]</p><p><strong>银行家算法描述</strong><br>设Requesti是进程Pi的请求矢量，如果Requesti[j]=K，表示进程Pi需要Rj类资源K个。当Pi发出资源请求后，系统按下述步骤进行检查：</p><p>①如果Requesti[j] &lt;= Need[i, j]，便转向步骤②；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。<br>②如果Requesti[j] &lt;= Available[j]，便转向步骤③;否则，表示尚无足够资源，Pi须等待。<br>③系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available[j] = Available[j] - Requesti[j];  </span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Requesti[ j];  </span><br><span class="line">Need[i, j] = Need[i, j] - Requesti[j];</span><br></pre></td></tr></table></figure></p><p>④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p><p><strong>安全性算法</strong><br>①设置两个矢量。<br>工作矢量Work；它表示系统可提供给进程继续运行所需的各类资源数目，它含有所个元素，在执行安全算法开始时，Work=Available;<br>Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时 Finish[i]=false；当有足够资源分配给进程 Pi 时，再令 Finish[i]=true。<br>②从进程集合中找到一个能满足下述条件的进程：Finish[i]=false;    Need[i, j]&lt;=Work[j]; 若找到，执行下一步骤，否则，执行步骤4。<br>③当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Work[j]=Work[j]+Allocation[i, j];</span><br><span class="line">Finish[i]=true;</span><br><span class="line">go to step &lt;2&gt;;</span><br></pre></td></tr></table></figure></p><p>④如果所有进程的Finish[i]=tme都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p><h6 id="银行家算法举例"><a href="#银行家算法举例" class="headerlink" title="银行家算法举例"></a>银行家算法举例</h6><p>假定系统中有5个进程{P0, P1, P2, P3, P4}和三类资源{A, B, C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况见表2-16。</p><ul><li>T0时刻的安全性。<br>利用安全性算法对T0时刻的资源分配进行分析，由表2-17可知，在T0时刻存在着一个安全序列{P1, P3, P4, P2, P0}，故系统是安全的。<br><img src="bank_algorithm.png" alt></li><li>P1请求资源<br>P1发出请求矢量Request1(l，, 0, 2)，系统按银行家算法进行检查：</li><li>Request1(1, 0, 2) &lt;= Need1(l, 2, 2)。</li><li>Request1(1, 0, 2) &lt;= Available1(3, 3, 2)。</li><li>系统先假定可为P1分配资源，并修改Available、Allocation1和Need1矢量，由此形成的资源变化情况见表2-18。</li><li>再利用安全性算法检查此时系统是否安全。<br><img src="bank_algorithm_2.png" alt></li><li>P4请求资源<br>P4发出请求矢量Request4(3, 3, 0)，系统按银行家算法进行检查：<br>Request4(3, 3, 0) &lt;= Need4(4, 3, 1)。<br>Request4(3, 3, 0) &gt; Available(2, 3, 0)，让 P4 等待。</li><li>P0请求资源<br>P0发出请求矢量Request0(0, 2, 0)，系统按银行家算法进行检查：<br>Request0(0, 2, 0) &lt;= Need0(7, 4, 3)。<br>Request0(0, 2, 0) &lt;= Available(2, 3, 0)。<br>系统暂时先假定可为P0分配资源，并修改有关数据，见表2-19。<br><img src="bank_algorithm_3.png" alt></li><li>进行安全性检测。<br>可用资源Available(2, 1, 0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。</li></ul><h5 id="死锁的检测及解除"><a href="#死锁的检测及解除" class="headerlink" title="死锁的检测及解除"></a>死锁的检测及解除</h5><p>前面绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不釆取任何措施，则应该提供死锁检测和解除的手段。</p><h6 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h6><p>系统死锁，可利用资源分配图来描述。<br>如图2-17所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。<br><img src="lock_check.png" alt><br>在图2-17所示的资源分配图中，进程P1已经分得了两个R1资源，并又请求一个R2 资源；进程P2分得了一个R1和一个R2资源，并又请求一个R1资源。</p><h6 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h6><p>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：</p><ul><li><p>在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图2-18(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图248(b)所示的情况。</p></li><li><p>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2-17中，进程P2就满足这样的条件。根据第1) 条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图2-18(c)所示。<br><img src="deadlock_relieve.png" alt><br>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理。</p></li></ul><h6 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h6><p>一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要方法有：</p><ul><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。  </li><li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。  </li><li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="http://www.blogjava.net/junglesong/archive/2008/02/22/181356.html" target="_blank" rel="noopener">和风细雨</a><br>[2] <a href="http://c.biancheng.net/cpp/u/xitong_2/" target="_blank" rel="noopener">计算机操作系统</a><br>[3] <a href="http://www.cnblogs.com/mickole/category/496206.html" target="_blank" rel="noopener">mickole</a>  </p><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>[1] [操作系统概念 第7版]<br>[2] [UNIX环境高级编程]<br>[3] [UNIX网络编程_卷2_进程间通信]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;以哲学思想定制学习框架&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;唯物辩证法（Materialist Dialectics），是一种研究自然、社会、历史和思维的哲学方法。&lt;em&gt;此处为研究多进程编程&lt;/em&gt;&lt;br&gt;唯物辩证法试图回答的问题是“世界的存在状态问题”。世界存在的基本特征有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;世界是普遍联系的&lt;br&gt;矛盾（即对立统一）是事物普遍联系的根本内容。&lt;br&gt;矛盾的双方总是“相比较而存在，相斗争而发展”的&lt;/li&gt;
&lt;li&gt;世界是永恒发展的&lt;br&gt;所谓发展，是指事物由简单到复杂、由低级到高级的变化趋势&lt;br&gt;其实质是新事物的产生和旧事物的灭亡。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://gitforhzc.github.io/categories/Concurrency/"/>
    
    
      <category term="threads" scheme="http://gitforhzc.github.io/tags/threads/"/>
    
  </entry>
  
  <entry>
    <title>Socket编程</title>
    <link href="http://gitforhzc.github.io/2016/08/01/Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://gitforhzc.github.io/2016/08/01/Socket编程/</id>
    <published>2016-07-31T23:08:30.000Z</published>
    <updated>2019-06-08T11:05:57.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="以软件工程思维来定制项目框架"><a href="#以软件工程思维来定制项目框架" class="headerlink" title="以软件工程思维来定制项目框架"></a>以软件工程思维来定制项目框架</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><strong>阐明将要解决的问题</strong><br>服务器端:<br>接收客户端信息，如信息为“Query”，则打印“Receive Query”<br>客户端：<br>向地址127.0.0.1的服务器端顺序发送信息“Query test”，“Query”，“Query Quit”，然后退出。<br>题目中出现的ip地址可以根据实际情况定。</p><a id="more"></a><hr><h3 id="网络中进程之间如何通信？"><a href="#网络中进程之间如何通信？" class="headerlink" title="网络中进程之间如何通信？"></a>网络中进程之间如何通信？</h3><h4 id="本地进程间通信"><a href="#本地进程间通信" class="headerlink" title="本地进程间通信"></a>本地进程间通信</h4><ul><li>本地进程标识<br>PID</li><li>本地进程通信方式<br>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类:<ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC)   </li></ul></li></ul><h4 id="网络进程间通信"><a href="#网络进程间通信" class="headerlink" title="网络进程间通信"></a>网络进程间通信</h4><ul><li>网络进程标识<br>三元组(IP，协议，端口)<br>网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</li><li>网络进程通信方式<br>使用TCP/IP协议的应用程序通常采用应用编程接口(API)：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我[原作者]为什么说“一切皆socket”。   </li></ul><hr><h3 id="Socket与TCP是什么关系"><a href="#Socket与TCP是什么关系" class="headerlink" title="Socket与TCP是什么关系?"></a>Socket与TCP是什么关系?</h3><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br><img src="tcp_socket.jpg" alt>  </p><h4 id="Socket应用编程接口-API"><a href="#Socket应用编程接口-API" class="headerlink" title="Socket应用编程接口(API)"></a>Socket应用编程接口(API)</h4><p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。<br><img src="socket.jpg" alt></p><h4 id="Socket中TCP的三次握手建立连接详解"><a href="#Socket中TCP的三次握手建立连接详解" class="headerlink" title="Socket中TCP的三次握手建立连接详解"></a>Socket中TCP的三次握手建立连接详解</h4><p>  tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：  </p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li><p>客户端再想服务器发一个确认ACK K+1  </p><p>这样就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：<br><img src="tcp_connect_socket.png" alt><br>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。  </p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote></li></ul><h4 id="Socket中TCP的四次握手释放连接详解"><a href="#Socket中TCP的四次握手释放连接详解" class="headerlink" title="Socket中TCP的四次握手释放连接详解"></a>Socket中TCP的四次握手释放连接详解</h4><p><img src="tcp_disconnect_socket.png" alt><br>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><h4 id="Socket中TCP的通讯流程"><a href="#Socket中TCP的通讯流程" class="headerlink" title="Socket中TCP的通讯流程"></a>Socket中TCP的通讯流程</h4><p>在学习socket API时要注意应用程序和TCP协议层是如何交互的：</p><ul><li>应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段  </li><li>应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段</li></ul><p>下图是基于TCP协议的客户端/服务器程序的一般流程：<br><img src="tcpflowchart.png" alt>    </p><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。</p><h5 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h5><p>建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。</p><h5 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h5><p>如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。</p><hr><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>设计解决问题需要的接口</p><h3 id="socket接口"><a href="#socket接口" class="headerlink" title="socket接口"></a>socket接口</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h4><p><code>int socket(int domain, int type, int protocol);</code>  </p><ul><li>功能描述<br>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</li><li><p>参数描述<br>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain<br>即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，IPv4、IPv6和UNIX Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。<br>在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li><p>type<br>指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_SEQPACKET等等。</p><ul><li>SOCK_STREAM<br>流套接字（SOCK_STREAM）：流套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission Control Protocol）协议。</li><li>SOCK_DGRAM<br>数据报套接字（SOCK_DGRAM）：数据报套接字提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。由于数据包套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。</li><li>SOCK_RAW<br>原始套接字(SOCK_RAW)：原始套接字与标准套接字（标准套接字指的是前面介绍的流套接字和数据报套接字）的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。<br>这个socket类型提供单一的网络访问，使用ICMP公共协议。（ping、traceroute使用该协议）  </li><li>SOCK_SEQPACKET<br>这个协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</li></ul></li><li><p>protocol<br>故名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。<br>注意： 并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p></li></ul></li><li><p>返回值描述<br>如果发生错误，函数返回值为-1。 否则，函数会返回一个代表新分配的描述符的整数。<br>当我们调用socket创建一个socket时，返回的是监听socket描述字，它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p></li></ul><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p><ul><li>功能描述<br>bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</li><li>参数描述<ul><li>sockfd<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是给这个描述字绑定一个名字。</li><li>addr<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。  </li><li>addrlen<br>对应的是地址的长度。<br>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</li></ul></li><li>返回值描述<br>如果发生错误，函数返回值为-1，否则为0。</li></ul><h4 id="listen-、connect"><a href="#listen-、connect" class="headerlink" title="listen()、connect()"></a>listen()、connect()</h4><p><code>int listen(int sockfd, int backlog);</code><br><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p><ul><li>功能描述<br>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</li><li>参数描述<ul><li>listen函数<br>第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。</li><li>connect函数<br>第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。</li></ul></li><li>返回值描述<br>返回-1表示出错，0表示成功<br>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</li></ul><h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p><ul><li>功能描述<br>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</li><li>参数描述<br>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。  </li><li>返回值描述<br>返回新的套接字描述符，称为<strong>连接socket描述字</strong>；出错返回-1。进一步的通信必须通过这个套接字。<br>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。accept函数返回的是已连接的socket描述字；而accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong>监听socket描述字</strong>。而一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。  </li></ul><h4 id="read-、write"><a href="#read-、write" class="headerlink" title="read()、write()"></a>read()、write()</h4><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！<br><code>#include &lt;unistd.h&gt;</code><br><code>ssize_t read(int fd, void *buf, size_t count);</code><br><code>ssize_t write(int fd, const void *buf, size_t count);</code></p><ul><li>描述：  <ul><li>read函数<br>负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</li><li>write函数<br>将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</li></ul></li></ul><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><code>#include &lt;unistd.h&gt;</code><br><code>int close(int fd);</code></p><ul><li>描述<br>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。<br>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</li></ul><hr><h3 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h3><p>…</p><p>…</p><p>…</p><hr><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>实现非现成的接口<br>源文件托管在<a href="https://github.com/gitforhzc/basic_socket_c" target="_blank" rel="noopener">https://github.com/gitforhzc/basic_socket_c</a></p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// file: server.c</span><br><span class="line">#include &lt;arpa/inet.h&gt;  // for htonl(), htons()</span><br><span class="line">#include &lt;errno.h&gt;      // for errno</span><br><span class="line">#include &lt;netinet/in.h&gt; // for sockaddr_in, INADDR_ANY</span><br><span class="line">#include &lt;stdio.h&gt;      </span><br><span class="line">#include &lt;stdlib.h&gt;     // for exit()</span><br><span class="line">#include &lt;string.h&gt;     // for memset()，strerror()</span><br><span class="line">#include &lt;sys/socket.h&gt; // for sockaddr ...</span><br><span class="line">#include &lt;sys/types.h&gt;  // for ...</span><br><span class="line"></span><br><span class="line">#define MAXLINE 4096</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  int listenfd, connfd;</span><br><span class="line">  struct sockaddr_in servaddr;</span><br><span class="line">  char buff[MAXLINE];</span><br><span class="line">  int n;</span><br><span class="line"></span><br><span class="line">  if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123;</span><br><span class="line">    printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  // INADDR_ANY就是指定地址为0.0.0.0的地址</span><br><span class="line">  // 这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</span><br><span class="line">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">  servaddr.sin_port = htons(6666);</span><br><span class="line"></span><br><span class="line">  if (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) == -1) &#123;</span><br><span class="line">    printf(&quot;bind socket error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (listen(listenfd, 10) == -1) &#123;</span><br><span class="line">    printf(&quot;listen socket error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;======waiting for client&apos;s request======\n&quot;);</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    if ((connfd = accept(listenfd, (struct sockaddr *)NULL, NULL)) == -1) &#123;</span><br><span class="line">      printf(&quot;accept socket error: %s(errno: %d)&quot;, strerror(errno), errno);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    n = recv(connfd, buff, MAXLINE, 0);</span><br><span class="line">    buff[n] = &apos;\0&apos;;</span><br><span class="line">    printf(&quot;recv msg from client: %s\n&quot;, buff);</span><br><span class="line">    close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(listenfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// file: client.c</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 4096</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  int sockfd, n;</span><br><span class="line">  char recvline[4096], sendline[4096];</span><br><span class="line">  struct sockaddr_in servaddr;</span><br><span class="line"></span><br><span class="line">  if (argc != 2) &#123;</span><br><span class="line">    printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;</span><br><span class="line">    printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;</span><br><span class="line">  servaddr.sin_port = htons(6666);</span><br><span class="line">  if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) &#123;</span><br><span class="line">    printf(&quot;inet_pton error for %s\n&quot;, argv[1]);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;</span><br><span class="line">    printf(&quot;connect error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;send msg to server: \n&quot;);</span><br><span class="line">  fgets(sendline, MAXLINE, stdin);</span><br><span class="line">  if (send(sockfd, sendline, strlen(sendline), 0) &lt; 0) &#123;</span><br><span class="line">    printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(sockfd);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><p>测试接口并提供测试用例</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// file: Makefile</span><br><span class="line">TARGET = server client</span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -g</span><br><span class="line"></span><br><span class="line">all:$(TARGET)</span><br><span class="line"></span><br><span class="line">server:server.c</span><br><span class="line">$(CC) $(CFLAGS) -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">client:client.c</span><br><span class="line">$(CC) $(CFLAGS) -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -rf $(TARGET)</span><br></pre></td></tr></table></figure><p>执行<br><code>make</code></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>开启服务<br><code>./server</code><br>连接服务器<br><code>./client 127.0.0.1</code></p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>本机地址、局域网IP地址测试成功；<br>限于没有公网IP，广域网IP地址并未测试  </p><h4 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h4><ul><li>信息长度<br><code>#define MAXLINE 4096</code><br>由此可设定</li><li>信息支持的字符<br><code>char buff[MAXLINE];</code><br>任何可用char表示的值</li></ul><hr><h2 id="程序维护"><a href="#程序维护" class="headerlink" title="程序维护"></a>程序维护</h2><p><strong>修改以前阶段的成果并改进</strong><br>实现简单的即时聊天工具服务端及客户端：服务端与客户端互相发送消息<br>pthread</p><hr><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>如果读代码有障碍，可来此学习基础知识</p><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在调用C语言程序时，可以将命令行参数传递给主函数main。<br><code>main(int argc,char *argv[])</code><br>主函数main有两个参数：1.argc(参数数目)  2.argv(一个指向字符串数组的指针)  </p><p>例:linux命令echo.在linux命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  echo Hello, World</span><br><span class="line">Hello, World</span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure></p><p><img src="echo.png" alt><br>命令行各参数用空格隔开，按照C语言约定，argv[0]为程序名.argv[1]……argv[argc-1]为可选参数.</p><h3 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h3><h4 id="指示错误代号errno"><a href="#指示错误代号errno" class="headerlink" title="指示错误代号errno"></a>指示错误代号errno</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">extern int errno;</span><br></pre></td></tr></table></figure><p>errno.h中的C标准库的头文件中定义的整数变量errno，這是由系统调用和一些库函数的错误事件指明什麼地方出了错。该宏展开为int类型的修改的左值，因此它可以同時读取和修改程序。</p><p>errno設置為零，在程序启动时，标准C库中的某些功能修改它的值到一些异于零值，某些类型的错误信号。您还可以修改它的值，或在方便時归零。</p><h4 id="描述错误信息strerror"><a href="#描述错误信息strerror" class="headerlink" title="描述错误信息strerror()"></a>描述错误信息strerror()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char *strerror(int errnum);</span><br></pre></td></tr></table></figure><p>strerror函数把其中一个错误代码作为参数，并返回一个指向用于描述错误的字符串的指针。</p><h4 id="自定义错误信息perror"><a href="#自定义错误信息perror" class="headerlink" title="自定义错误信息perror()"></a>自定义错误信息perror()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">void perror(char const *message);</span><br></pre></td></tr></table></figure><p>如果message不是NULL并且指向一个非空的字符串，perror函数就打印出这个字符串，用于解释errno当前错误代码的信息。</p><hr><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>多字节数据高低字节的存储顺序  </p><h3 id="主机字节序"><a href="#主机字节序" class="headerlink" title="主机字节序"></a>主机字节序</h3><p>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指多字节数据在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：  </p><ul><li>Little-Endian<br>低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li><li>Big-Endian<br>高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li></ul><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？  </p><ul><li>发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出</li><li>接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存  </li></ul><p>因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p><strong>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。</strong><br>例如，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><h3 id="主机字节序与网络字节序的转换"><a href="#主机字节序与网络字节序的转换" class="headerlink" title="主机字节序与网络字节序的转换"></a>主机字节序与网络字节序的转换</h3><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br><span class="line">uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure></p><p>这些函数名很好记，h表示host，n表示network，l表示32位长整数，s表示16位短整数。<br>例如htonl表示将32位的长整数从主机字节序转换为网络字节序。  </p><ul><li>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回</li><li>如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</li></ul><hr><h2 id="Socket地址的数据类型"><a href="#Socket地址的数据类型" class="headerlink" title="Socket地址的数据类型"></a>Socket地址的数据类型</h2><p>Socket API是一层抽象的网络编程接口，适用于各种底层网络协议，如IPv4、IPv6以及UNIX Domain Socket。然而，各种网络协议的地址格式并不相同，各种Socket地址数据结构如下图所示：  </p><p><img src="/2016/08/01/basic-socket-c/sockaddr.png" alt></p><h3 id="netinet-in-h"><a href="#netinet-in-h" class="headerlink" title="netinet/in.h"></a>netinet/in.h</h3><p>IPv4和IPv6的地址格式定义在netinet/in.h中<br>IPv4地址用sockaddr_in结构体表示，包括16位地址类型,16位端口号和32位IP地址<br>IPv6地址用sockaddr_in6结构体表示，包括16位地址类型,16位端口号、128位IP地址和一些控制字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// file: netinet/in.h</span><br><span class="line">// ipv4</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">    in_port_t      sin_port;   /* port in network byte order */</span><br><span class="line">    struct in_addr sin_addr;   /* internet address */</span><br><span class="line">&#125;;</span><br><span class="line">/* Internet address. */</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t       s_addr;   /* address in network byte order */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ipv6</span><br><span class="line">struct sockaddr_in6 &#123;</span><br><span class="line">    sa_family_t     sin6_family;   /* AF_INET6 */</span><br><span class="line">    in_port_t       sin6_port;     /* port number */</span><br><span class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */</span><br><span class="line">    struct in6_addr sin6_addr;     /* IPv6 address */</span><br><span class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */</span><br><span class="line">&#125;;</span><br><span class="line">struct in6_addr &#123;</span><br><span class="line">    unsigned char   s6_addr[16];   /* IPv6 address */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="sys-un-h"><a href="#sys-un-h" class="headerlink" title="sys/un.h"></a>sys/un.h</h3><p>UNIX Domain Socket的地址格式定义在sys/un.h中，用sockaddr_un结构体表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// file: sys/un.h</span><br><span class="line">#define UNIX_PATH_MAX    108</span><br><span class="line">struct sockaddr_un &#123;</span><br><span class="line">    sa_family_t sun_family;               /* AF_UNIX */</span><br><span class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="sys-socket-h"><a href="#sys-socket-h" class="headerlink" title="sys/socket.h"></a>sys/socket.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// file: sys/socket.h</span><br><span class="line">struct sockaddr</span><br><span class="line">  &#123;</span><br><span class="line">    unsigned short int sa_family; /* address family, AF_xxx */</span><br><span class="line">    unsigned char sa_data[14];  /* 14 bytes of protocol address */</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>以上各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。<br>IPv4、IPv6和UNIX Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。<br>因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">/* initialize servaddr */</span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br></pre></td></tr></table></figure></p><h3 id="arpa-inet-h"><a href="#arpa-inet-h" class="headerlink" title="arpa/inet.h"></a>arpa/inet.h</h3><p>本节只讨论基于IPv4的socket网络编程，sockaddr_in中的成员struct in_addr sin_addr表示32位的IP地址。但是我们通常用点分十进制的字符串表示IP地址，以下函数可以在字符串表示和in_addr表示之间转换。</p><ul><li><p>字符串转in_addr的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int inet_aton(const char *strptr, struct in_addr *addrptr);</span><br><span class="line">in_addr_t inet_addr(const char *strptr);</span><br><span class="line">int inet_pton(int family, const char *strptr, void *addrptr);</span><br></pre></td></tr></table></figure></li><li><p>in_addr转字符串的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *inet_ntoa(struct in_addr inaddr);</span><br><span class="line">const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。这一参考模型共分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层，如下图所示。<br><img src="OSI.jpg" alt></p><h4 id="第1层-物理层-Physical-Layer"><a href="#第1层-物理层-Physical-Layer" class="headerlink" title="第1层 物理层(Physical Layer)"></a>第1层 物理层(Physical Layer)</h4><ul><li>最底层是物理层，指的是电信号的传递方式，比如现在以太网通用的网线（双绞线）、早期以太网采用的的同轴电缆（现在主要用于有线电视）、光纤等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。  </li><li>集线器（Hub）、中继器是工作在物理层的网络设备，用于双绞线的连接和信号中继（将已衰减的信号再次放大使之传得更远）。</li></ul><h4 id="第2层-数据链路层-Data-Link-Layer"><a href="#第2层-数据链路层-Data-Link-Layer" class="headerlink" title="第2层 数据链路层(Data Link Layer)"></a>第2层 数据链路层(Data Link Layer)</h4><ul><li>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（就是说从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。  </li><li>交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</li></ul><h4 id="第3层-网络层-Network-Layer"><a href="#第3层-网络层-Network-Layer" class="headerlink" title="第3层 网络层(Network Layer)"></a>第3层 网络层(Network Layer)</h4><ul><li>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Internet上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。  </li><li>路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</li></ul><h4 id="第4层-传输层-Transport-Layer"><a href="#第4层-传输层-Transport-Layer" class="headerlink" title="第4层 传输层(Transport Layer)"></a>第4层 传输层(Transport Layer)</h4><p>网络层负责点到点（point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。  </p><ul><li>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。  </li><li>UDP协议不面向连接，也不保证可靠性，有点像寄信，写好信放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件是按顺序寄到目的地的。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</li></ul><h4 id="第5层-会话层-Session-Layer"><a href="#第5层-会话层-Session-Layer" class="headerlink" title="第5层 会话层(Session Layer)"></a>第5层 会话层(Session Layer)</h4><p>负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</p><h4 id="第6层-表示层-Presentation-Layer"><a href="#第6层-表示层-Presentation-Layer" class="headerlink" title="第6层 表示层(Presentation Layer)"></a>第6层 表示层(Presentation Layer)</h4><p>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><h4 id="第7层-应用层-Application-Layer"><a href="#第7层-应用层-Application-Layer" class="headerlink" title="第7层 应用层(Application Layer)"></a>第7层 应用层(Application Layer)</h4><p>提供为应用软件而设的界面，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</p><p><strong>注意：OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念性框架。</strong></p><h3 id="TCP-IP参考模型-TCP-IP协议栈"><a href="#TCP-IP参考模型-TCP-IP协议栈" class="headerlink" title="TCP/IP参考模型(TCP/IP协议栈)"></a>TCP/IP参考模型(TCP/IP协议栈)</h3><p> 互联网协议族（英语：Internet Protocol Suite，缩写为IPS），是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。因为这个协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），是这个家族中最早通过的标准，它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，这些协议分布在参考模型的不同层中的，因此又被称为<strong>TCP/IP协议栈</strong>（英语：TCP/IP Protocol Stack）。</p><p> TCP/IP参考模型是一个抽象的分层模型，在这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的”层”中，常被视为是简化的七层OSI模型。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。<br> <img src="tcpip_stack.png" alt></p><h3 id="TCP-IP协议栈的通讯过程"><a href="#TCP-IP协议栈的通讯过程" class="headerlink" title="TCP/IP协议栈的通讯过程"></a>TCP/IP协议栈的通讯过程</h3><p><strong>将以下所说的链路层视作网络接口层</strong><br>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示（该图出自[TCPIP]）。<br><img src="tcpip_stack2.png" alt>  </p><h4 id="同一网段的通讯"><a href="#同一网段的通讯" class="headerlink" title="同一网段的通讯"></a>同一网段的通讯</h4><p>两台计算机通过TCP/IP协议通讯的过程如下所示（该图出自[TCPIP]）。<br><img src="tcpip_transferlan.png" alt>  </p><p>传输层及其以下的机制由内核提供，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层由用户进程提供（使用socket API编写应用程序），应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示（该图出自[TCPIP]）。<br><img src="tcpip_datagram.png" alt></p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p><h4 id="不同网段的通讯"><a href="#不同网段的通讯" class="headerlink" title="不同网段的通讯"></a>不同网段的通讯</h4><p>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示（该图出自[TCPIP]）。<br><img src="tcpip_transferovernet.png" alt></p><p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？整个过程如下图所示（该图出自[TCPIP]）。<br><img src="tcpip_multiplex.png" alt>   </p><ol><li>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。  </li><li>假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。</li><li>假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</li></ol><p><strong>注意，虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。本文对RARP、ICMP、IGMP协议不做进一步介绍，有兴趣的读者可以看参考资料。</strong></p><hr><h1 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h1><p>[1] [Linux Socket编程]：<a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html</a>  </p><p>[2] [揭开Socket编程的面纱]： <a href="http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx" target="_blank" rel="noopener">http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx</a></p><p>[3] [第37章 socket编程]: <a href="https://akaedu.github.io/book/ch37s01.html" target="_blank" rel="noopener">https://akaedu.github.io/book/ch37s01.html</a></p><p>[4] [C语言]：<a href="https://freehuoshan.gitbooks.io/c-language/content/zs/command.html" target="_blank" rel="noopener">https://freehuoshan.gitbooks.io/c-language/content/zs/command.html</a></p><hr><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>[1] UNIX环境高级编程 第二版<br>[2] UNIX网络编程卷1：套接字联网API（第3版）<br>[3] TCP-IP详解卷一：协议  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;以软件工程思维来定制项目框架&quot;&gt;&lt;a href=&quot;#以软件工程思维来定制项目框架&quot; class=&quot;headerlink&quot; title=&quot;以软件工程思维来定制项目框架&quot;&gt;&lt;/a&gt;以软件工程思维来定制项目框架&lt;/h1&gt;&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;阐明将要解决的问题&lt;/strong&gt;&lt;br&gt;服务器端:&lt;br&gt;接收客户端信息，如信息为“Query”，则打印“Receive Query”&lt;br&gt;客户端：&lt;br&gt;向地址127.0.0.1的服务器端顺序发送信息“Query test”，“Query”，“Query Quit”，然后退出。&lt;br&gt;题目中出现的ip地址可以根据实际情况定。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://gitforhzc.github.io/categories/Network/"/>
    
    
      <category term="socket" scheme="http://gitforhzc.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>share-music</title>
    <link href="http://gitforhzc.github.io/2016/07/15/share-music/"/>
    <id>http://gitforhzc.github.io/2016/07/15/share-music/</id>
    <published>2016-07-15T09:52:41.000Z</published>
    <updated>2019-06-08T11:05:57.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="音乐插件"><a href="#音乐插件" class="headerlink" title="音乐插件"></a>音乐插件</h2><h3 id="hexo-tag-aplayer"><a href="#hexo-tag-aplayer" class="headerlink" title="hexo-tag-aplayer"></a>hexo-tag-aplayer</h3><ul><li><p>installation  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure></li><li><p>usage<br>With post asset folders enabled, you can easily place your image, music and LRC file into asset folder, and reference them like:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125;</span><br></pre></td></tr></table></figure><blockquote><p> aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx]</p></blockquote></li></ul><a id="more"></a><h3 id="获取mp3外链"><a href="#获取mp3外链" class="headerlink" title="获取mp3外链"></a>获取mp3外链</h3><h4 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h4><p>方法有二：  </p><ul><li>网易云音乐api<br><a href="http://music.163.com/api/song/detail/?id=29497667&amp;ids=%5B29497667%5D&amp;csrf_token=" target="_blank" rel="noopener">http://music.163.com/api/song/detail/?id=29497667&amp;ids=%5B29497667%5D&amp;csrf_token=</a><br>修改两处歌曲id，复制到浏览器地址栏，获取mp3url</li></ul><ul><li>网易云音乐通用外链地址<br><a href="http://music.163.com/song/media/outer/url?id=28456751.mp3" target="_blank" rel="noopener">http://music.163.com/song/media/outer/url?id=28456751.mp3</a><br>修改一处歌曲id，复制到aplayer标签url直接可用</li></ul><h4 id="虾米音乐"><a href="#虾米音乐" class="headerlink" title="虾米音乐"></a>虾米音乐</h4><p><a href="http://www.0e99.com/musicbox/music.htm" target="_blank" rel="noopener">http://www.0e99.com/musicbox/music.htm</a><br>《虾米音乐网MP3网址外链转换》能将虾米音乐网的音乐网址转换为可供外链的MP3网址。如果转换成功立即播放并可复制转换后的MP3网址。<br>操作方法：打开虾米音乐网，查找你需要的音乐。复制音乐ID或网页地址</p><p align="center"><embed height="100" allownetworking="internal" width="600" allowscriptaccess="never" quality="high" invokeurls="false" src="http://dashan.gotoip1.com/gj/xiami-gqwl.swf" type="application/x-shockwave-flash" wmode="transparent" style="z-index: 0;"></p>  <h4 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h4><p><a href="http://www.qqmusic.cc/somusic" target="_blank" rel="noopener">http://www.qqmusic.cc/somusic</a><br>输入歌手或歌名搜索，获取外链</p><h3 id="获取lrc歌词"><a href="#获取lrc歌词" class="headerlink" title="获取lrc歌词"></a>获取lrc歌词</h3><p>前提：下载音乐到本地</p><h4 id="autolrc"><a href="#autolrc" class="headerlink" title="autolrc"></a>autolrc</h4><ul><li>download<br><code>http://www.autolyric.com/zh-hant/download</code></li><li><p>setting  </p><ul><li><p>歌词文件编码  </p><blockquote><p>选项-&gt;歌词下载-&gt;歌词保存文件编码：UTF-8</p></blockquote></li><li><p>歌词保存目录</p><blockquote><p>选项-&gt;歌词下载-&gt;歌词保存目录-&gt;歌曲文件保存目录</p></blockquote></li><li><p>调整歌词</p><blockquote><p>歌词-&gt;调整歌词-&gt;鼠标滚轮直接调整</p></blockquote></li></ul></li></ul><h4 id="zonylrcdownload"><a href="#zonylrcdownload" class="headerlink" title="zonylrcdownload"></a>zonylrcdownload</h4><ul><li>download<br><code>https://link.zhihu.com/?target=http%3A//www.myzony.com/usr/uploads/2016/05/3.2.zip</code></li><li><p>setting</p><ul><li><p>歌词文件编码</p><blockquote><p>设置-&gt;输出-&gt;编码格式-&gt;UTF-8</p></blockquote></li><li><p>歌词保存目录</p><blockquote><p>设置-&gt;输出-&gt;输出目录-&gt;写到同目录</p></blockquote></li><li><p>插件(避免下载错误歌词)</p><blockquote><p>插件-&gt;只勾选网易云音乐</p></blockquote></li></ul></li></ul><h3 id="参考致谢"><a href="#参考致谢" class="headerlink" title="参考致谢"></a>参考致谢</h3><p>[1] hexo-tag-aplayer:  <a href="https://github.com/grzhan/hexo-tag-aplayer" target="_blank" rel="noopener">https://github.com/grzhan/hexo-tag-aplayer</a></p><hr><h2 id="分享音乐"><a href="#分享音乐" class="headerlink" title="分享音乐"></a>分享音乐</h2><h3 id="It-Is-Well-Live"><a href="#It-Is-Well-Live" class="headerlink" title="It Is Well (Live)"></a>It Is Well (Live)</h3><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[ti:It Is Well (Live)][ar:Bethel Music/Kristene Dimarco][al:You Make Me Brave (Live)][ed:2][00:02.395]Bethel Music/Kristene Dimarco - It Is Well (Live)[00:05.932][00:37.119][00:51.771][01:06.649][01:29.003][01:41.783][02:11.439][03:04.250][05:34.946][06:10.137][00:13.109]Grander [00:13.833]earth [00:14.479]has [00:14.786]quaked [00:15.356]before[00:16.562][00:19.936]Moved [00:20.376]by [00:21.131]the [00:21.439]sound [00:21.788]of [00:22.038]His [00:22.306]voice[00:22.952][00:25.946]Seas [00:26.361]that [00:26.637]are [00:27.298]shaken [00:28.355]and [00:28.670]stirred[00:29.534][00:32.029]Can [00:32.265]be [00:32.562]calmed [00:32.853]and [00:33.138]broken [00:34.062]for [00:34.403]my [00:34.783]regard[00:35.923][00:38.273]And [00:38.504]through [00:38.729]it [00:39.002]all, [00:40.258]through [00:40.494]it [00:40.789]all[00:41.289][00:42.093]My [00:42.573]eyes [00:43.019]are [00:43.405]on [00:43.874]You[00:44.494][00:45.624]And [00:45.858]through [00:46.095]it [00:46.399]all, [00:47.433]through [00:47.754]it [00:48.124]all[00:48.531]It [00:49.015]is [00:49.499]well[00:50.591][00:53.005]And [00:53.208]through [00:53.430]it [00:53.734]all, [00:54.940]through [00:55.203]it [00:55.544]all[00:56.180][00:56.956]My [00:57.359]eyes [00:57.810]are [00:58.196]on [00:58.674]You[00:59.279][01:00.060]It [01:00.294]is [01:00.696]well [01:03.779]with [01:04.310]me[01:05.310][01:17.207]Far [01:17.615]be [01:17.855]it [01:18.037]from [01:18.346]me [01:18.846]to [01:19.143]not [01:19.752]believe[01:21.096][01:24.667]Even [01:24.992]when [01:25.618]my [01:26.016]eyes [01:26.427]can't [01:27.089]see[01:27.959][01:30.034]And [01:30.284]this [01:30.633]mountain [01:31.320]that's [01:31.914]in [01:32.279]front [01:32.886]of [01:33.235]me[01:33.975][01:36.573]Will [01:36.839]be [01:37.149]thrown [01:37.529]into [01:38.490]the [01:38.901]midst [01:39.314]of [01:39.583]the [01:39.918]sea[01:40.578][01:42.963]Through [01:43.198]it [01:43.564]all, [01:44.783]through [01:45.023]it [01:45.387]all[01:45.948][01:46.783]My [01:47.198]eyes [01:47.668]are [01:48.099]on [01:48.593]You[01:49.184][01:50.314]Through [01:50.562]it [01:50.948]all, [01:52.115]through [01:52.432]it [01:52.788]all[01:53.208]It [01:53.669]is [01:54.094]well[01:55.033][01:57.731]Through [01:57.942]it [01:58.265]all, [01:59.611]through [01:59.876]it [02:00.192]all[02:00.707][02:01.471]My [02:01.955]eyes [02:02.410]are [02:02.822]on [02:03.306]You[02:03.866][02:04.692]It [02:04.942]is [02:05.366]well[02:07.155][02:08.306]It [02:08.676]is [02:09.280]well[02:11.923]So [02:12.173]let [02:12.571]go [02:13.809]my [02:14.382]soul [02:15.673]and [02:16.217]trust [02:17.453]in [02:18.045]Him[02:18.764][02:19.220]The [02:19.458]waves [02:19.686]and [02:19.993]wind [02:21.214]still [02:21.730]know [02:23.155]His [02:23.670]name[02:26.660]So [02:26.910]let [02:27.260]go [02:28.620]my [02:29.130]soul [02:30.495]and [02:30.995]trust [02:32.084]in [02:32.774]Him[02:33.644][02:34.061]The [02:34.337]waves [02:34.644]and [02:34.925]wind [02:35.920]still [02:36.454]know [02:37.865]His [02:38.380]name[02:40.805][02:41.485]So [02:41.766]let [02:42.140]go [02:43.349]my [02:43.880]soul [02:45.245]and [02:45.735]trust [02:46.844]in [02:47.495]Him[02:48.479][02:48.837]The [02:49.055]waves [02:49.260]and [02:49.571]wind [02:50.735]still [02:51.250]know [02:52.584]His [02:53.130]name[02:54.821][02:56.321]The [02:56.561]waves [02:56.821]and [02:57.130]wind [02:58.099]still [02:58.630]know [03:00.077]His [03:00.571]name[03:02.849][03:06.490]It [03:07.551]is [03:08.360]well [03:13.892]with [03:14.902]my [03:15.876]soul[03:17.572][03:21.376]It [03:22.152]is [03:23.110]well [03:28.730]with [03:29.567]my [03:30.535]soul[03:33.307][03:36.082]It [03:36.937]is [03:37.848]well [03:43.452]with [03:44.332]my [03:45.285]soul[03:50.855][03:50.929]It [03:51.689]is [03:52.559]well [03:54.520]it [03:55.285]is [03:56.233]well [03:58.233]with [03:59.582]my [04:00.551]soul[04:02.475][04:05.188]It [04:06.464]is [04:07.378]well [04:09.772]it [04:10.040]is [04:10.426]well [04:12.965]with [04:13.821]my [04:14.715]soul[04:17.209][04:20.356]It [04:21.175]is [04:22.197]well [04:27.833]with [04:28.728]my [04:29.919]soul[04:32.783][04:35.207]It [04:36.004]is [04:36.864]well [04:42.559]with [04:43.364]my [04:44.468]soul[04:49.880]It [04:50.721]is [04:51.601]well [04:53.411]it [04:54.335]is [04:55.304]well [04:57.390]with [04:58.696]my [04:59.576]soul[05:01.652][05:04.637]It [05:05.548]is [05:06.418]well [05:08.342]it [05:09.196]is [05:10.098]well [05:12.038]with [05:13.418]my [05:14.434]soul[05:16.446][05:19.402]It [05:20.282]is [05:21.184]well [05:22.978]it [05:23.952]is [05:24.848]well [05:26.778]with [05:28.257]my [05:29.243]soul[05:32.611][05:41.046]Through [05:41.371]it [05:41.741]all, [05:42.931]through [05:43.264]it [05:43.611]all[05:44.124][05:44.741]My [05:45.339]eyes [05:45.824]are [05:46.290]on [05:46.725]You[05:47.280][05:48.431]Through [05:48.704]it [05:49.077]all, [05:50.324]through [05:50.589]it [05:50.957]all[05:51.386]It [05:51.858]is [05:52.313]well[05:53.857][05:55.842]Through [05:56.092]it [05:56.441]all, [05:57.751]through [05:58.007]it [05:58.342]all[05:58.795][05:59.741]My [06:00.165]eyes [06:00.631]are [06:01.055]on [06:01.472]You[06:02.076][06:02.738]It [06:03.017]is [06:03.419]well [06:06.587]with [06:07.102]me[06:08.238][6:20]-- AutoLyric (http://www.autolyric.com) --</pre></div><script>var aplayer0 = new APlayer({element: document.getElementById("aplayer0"),narrow: false,autoplay: false,showlrc: 2,music : {title: "It Is Well (Live)",author: "Bethel Music,Kristene Dimarco",url: "http://music.163.com/song/media/outer/url?id=28456751.mp3",pic: ""}});aplayer0.init();</script><hr><h3 id="大塚愛-クムリウタ-Live"><a href="#大塚愛-クムリウタ-Live" class="headerlink" title="大塚愛 - クムリウタ(Live)"></a>大塚愛 - クムリウタ(Live)</h3><div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[ti:クムリウタ][ar:大塚愛][al:ballad collection][ed:1][00:26.115]立ち止まってすべてを無にした[00:32.730]目をそらして　逃げてたことを[00:39.157]恥じらって　向かい合うことができたら[00:47.001]奇跡を信じた[00:54.077]大塚愛 - クムリウタ[00:59.577]作詞／作曲：愛[01:05.245]蝉は鳴く 響くように[01:11.571]歌うように[01:14.670]死んでいくかな[01:18.267]私も明日消えるなら　もっと[01:25.932]ちゃんといれるのかな?[01:32.460]ここに立っていることさえ[01:41.457]時々意識を失いそうになる[01:48.634]曇り空、泣くな[01:54.508]まだここは通過点で[02:01.248]曇り空、泣くな[02:07.514]心は本当は強い[02:16.043]Music...[02:26.439]フワフワ流れるように[02:32.884]なんとなく[02:35.720]過ごせるけれど[02:39.470]本当は虚しいことには　ずっと[02:47.050]前から気付いてた[02:53.430]傷を持って[02:58.391]もう一度って[03:02.534]強く誓え[03:06.401]自分を見捨てるな[03:09.641]曇り空、泣くな[03:15.609]せめて心を信じて[03:22.341]曇り空、泣くな[03:28.680]待ってる人はいる[03:32.005]深海の中を　くるり　泳いで[03:38.875]聞こえる水の声 思い出す[03:45.430]あの雨の日も[03:48.686]こんな暗くて[03:51.881]二つある扉[03:55.170]曇り空、泣くな[04:01.154]まだここは通過点で[04:07.739]曇り空、泣くな[04:14.011]心は本当は強い[04:20.729]曇り空、泣くな[04:27.094]まだここは通過点で[04:33.656]曇り空、泣くな[04:39.904]心は本当は強い[04:48.988]立ち止まって[04:51.933]すべてを無にした[04:55.410]目をそらして[04:58.366]逃げてたことを[05:02.059]恥じらって[05:04.920]向かい合うことができたら…[05:09.721]奇跡を信じた[05:19.499][05:22.700][05:58.000]-- AutoLyric (http://www.autolyric.com) --</pre></div><script>var aplayer1 = new APlayer({element: document.getElementById("aplayer1"),narrow: false,autoplay: false,showlrc: 2,music : {title: "クムリウタ(Live)",author: "大塚愛",url: "http://music.163.com/song/media/outer/url?id=29497667.mp3",pic: ""}});aplayer1.init();</script><hr><h3 id="莫文蔚-爱情-Live"><a href="#莫文蔚-爱情-Live" class="headerlink" title="莫文蔚 - 爱情(Live)"></a>莫文蔚 - 爱情(Live)</h3><div id="aplayer2" class="aplayer" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[00:23.699]要不是因为爱着你[00:29.399]怎么会夜深还没睡意[00:35.999]每个念头都关於你[00:41.560]我想你 想你 好想你[00:52.39][00:54.140]要不是因为爱着你[00:59.930]怎会有不安的情绪[01:05.980]每个莫名的日子里[01:12.90]我想你 想你 好想你[01:20.600][01:24.160]爱是折磨人的东西[01:29.800]却又舍不得这样放弃[01:35.800]不停揣测你的心理[01:41.500]可有 我姓名[01:46.500][01:47.420]爱是我唯一的秘密[01:53.170]让人心碎却又着迷[01:58.850]无论是用什么言语[02:04.960]只会 只会 思念你[02:12.170][02:16.239]要不是因为爱着你[02:22.649]怎会不经意就叹息[02:28.390]有种不完整的心情[02:34.440]爱你 爱着你</pre></div><script>var aplayer2 = new APlayer({element: document.getElementById("aplayer2"),narrow: false,autoplay: false,showlrc: 2,music : {title: "爱情(live)",author: "莫文蔚",url: "http://m2.music.126.net/PnrVZVM1VMZ61ZNV2YGw5g==/1122601371967144.mp3",pic: ""}});aplayer2.init();</script><hr><h3 id="田馥甄-小幸运"><a href="#田馥甄-小幸运" class="headerlink" title="田馥甄 - 小幸运"></a>田馥甄 - 小幸运</h3><div id="aplayer3" class="aplayer" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[ti:小幸运][ar:田馥甄][al:小幸运 - Single][00:03.400]小幸运[00:07.840]词:徐世珍/吴辉福   [00:10.979]曲:JerryC    [00:15.149]我听见雨滴落在青青草地[00:21.409]我听见远方下课钟声响起[00:27.659]可是我没有听见你的声音[00:32.687]认真 呼唤我姓名[00:39.700]爱上你的时候还不懂感情[00:45.720]离别了才觉得刻骨 铭心[00:51.868]为什么没有发现遇见了你[00:56.630]是生命最好的事情[01:02.328][02:51.520]也许当时忙着微笑和哭泣[01:08.220][02:57.400]忙着追逐天空中的流星[01:13.970][03:03.730]人理所当然的忘记[01:18.600][03:08.100]是谁风里雨里一直默默守护在原地[01:26.128][03:15.670]原来你是我最想留住的幸运[01:31.489][03:20.979]原来我们和爱情曾经靠得那么近[01:37.580][03:26.958]那为我对抗世界的决定[01:42.118][03:31.360]那陪我淋的雨[01:45.229][03:34.590]一幕幕都是你 一尘不染的真心[01:52.667][03:42.080]与你相遇 好幸运[01:55.700][03:45.159]可我已失去为你泪流满面的权利[02:01.779][03:51.187]但愿在我看不到的天际[02:06.289][03:55.909]你张开了双翼[02:09.510][03:59.080]遇见你的注定 (oh--) [02:13.850][04:06.578]她会有多幸运[02:29.110]青春是段跌跌撞撞的旅行[02:35.240]拥有着后知后觉的美丽[02:41.319]来不及感谢是你给我勇气[02:46.020]让我能做回我自己  [4:20]-- AutoLyric (http://www.autolyric.com) --</pre></div><script>var aplayer3 = new APlayer({element: document.getElementById("aplayer3"),narrow: false,autoplay: false,showlrc: 2,music : {title: "小幸运",author: "田馥甄",url: "http://link.hhtjim.com/xiami/1774490672.mp3",pic: ""}});aplayer3.init();</script><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;音乐插件&quot;&gt;&lt;a href=&quot;#音乐插件&quot; class=&quot;headerlink&quot; title=&quot;音乐插件&quot;&gt;&lt;/a&gt;音乐插件&lt;/h2&gt;&lt;h3 id=&quot;hexo-tag-aplayer&quot;&gt;&lt;a href=&quot;#hexo-tag-aplayer&quot; class=&quot;headerlink&quot; title=&quot;hexo-tag-aplayer&quot;&gt;&lt;/a&gt;hexo-tag-aplayer&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;installation  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save hexo-tag-aplayer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;usage&lt;br&gt;With post asset folders enabled, you can easily place your image, music and LRC file into asset folder, and reference them like:  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;% aplayer &amp;quot;Caffeine&amp;quot; &amp;quot;Jeff Williams&amp;quot; &amp;quot;caffeine.mp3&amp;quot; &amp;quot;picture.jpg&amp;quot; &amp;quot;lrc:caffeine.txt&amp;quot; %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt; aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="music" scheme="http://gitforhzc.github.io/categories/music/"/>
    
    
      <category term="music" scheme="http://gitforhzc.github.io/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>demo-2048-c</title>
    <link href="http://gitforhzc.github.io/2016/07/11/demo-2048-c/"/>
    <id>http://gitforhzc.github.io/2016/07/11/demo-2048-c/</id>
    <published>2016-07-10T20:30:47.000Z</published>
    <updated>2019-06-08T11:05:57.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>程序设计语言：C语言<br>游戏:2048<br>玩法：用WSAD控制上下左右方向,按Q退出游戏;<br>当两个<strong>相同</strong>数字方块发生碰撞，它们会<strong>累加</strong>起来成为一个新的数字方块，出现数字方块为2048时即可通关<br>源代码地址: <a href="https://github.com/gitforhzc/demo-2048-c" target="_blank" rel="noopener">https://github.com/gitforhzc/demo-2048-c</a><br><a href="#testing">编译源代码</a>，运行demo<code>./demo</code></p><a id="more"></a><p><img src="/2016/07/11/demo-2048-c/demo.png" alt></p><h2 id="Framwork"><a href="#Framwork" class="headerlink" title="Framwork"></a>Framwork</h2><ul><li>include</li><li>define</li><li>implement</li><li>main</li></ul><h2 id="design"><a href="#design" class="headerlink" title="design"></a>design</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul><li>stdafx.h    # pre-compile include file</li></ul><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>demo2048c.h<ul><li>declare global variable</li><li>declare global function</li></ul></li></ul><h3 id="implement"><a href="#implement" class="headerlink" title="implement"></a>implement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// file: stdafx.h</span><br><span class="line">#ifndef _STDAFX_H</span><br><span class="line"></span><br><span class="line">#include &lt;curses.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt; // for srand() rand() exit()</span><br><span class="line">#include &lt;string.h&gt; // for strcpy()</span><br><span class="line">#include &lt;time.h&gt;   // for time()</span><br><span class="line">#include &lt;unistd.h&gt; // for sleep()</span><br><span class="line"></span><br><span class="line">#define _STDAFX_H</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// file: demo2048c.h</span><br><span class="line">#ifndef _DEMO2048C_H</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">        global variable</span><br><span class="line">*/</span><br><span class="line">// 4*4方格</span><br><span class="line">int a[4][4];</span><br><span class="line">// 方格里空格的个数, 标记已移动</span><br><span class="line">int empty, moved;</span><br><span class="line">// 标记退出情况：初始值0 游戏中，1 退出， 2 输， 3 赢</span><br><span class="line">enum &#123;playing, quit, lose, win&#125; endflag;  </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">        global function</span><br><span class="line">*/</span><br><span class="line">void init();</span><br><span class="line">void add_number();</span><br><span class="line">void draw();</span><br><span class="line">void draw_one(int y, int x);</span><br><span class="line">void play();</span><br><span class="line">void left();</span><br><span class="line">void right();</span><br><span class="line">void up();</span><br><span class="line">void down();</span><br><span class="line">int game_over();</span><br><span class="line">int test_lose();</span><br><span class="line">void draw_over();</span><br><span class="line"></span><br><span class="line">#define _DEMO2048C_H</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// file: main.c</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;demo2048c.h&quot;</span><br><span class="line">int a[4][4] = &#123;0&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    play();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><p>编程思想：模块化<br>// file: demo2048c.c  </p><p>#include “stdafx.h”</p><p>#include “demo2048c.h”</p><h3 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// init 函数首先初始化屏幕，在方格中随机生成两个位置并放入随机数字2,4。</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    initscr();</span><br><span class="line">    cbreak();</span><br><span class="line">    noecho();</span><br><span class="line">    curs_set(0);</span><br><span class="line"></span><br><span class="line">    empty = sizeof(a) / sizeof(a[0][0]);</span><br><span class="line">    srand(time(0));</span><br><span class="line">    add_number();</span><br><span class="line">    add_number();</span><br><span class="line">    draw();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://stackoverflow.com/questions/7343833/srand-why-call-it-only-once/" target="_blank" rel="noopener">srand() — why call it only once?</a>  </p><h3 id="add-number"><a href="#add-number" class="headerlink" title="add_number()"></a>add_number()</h3><p>初始化数字和生成新数字整合成这一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// add_number 函数用于生成随机数</span><br><span class="line">void add_number() &#123;</span><br><span class="line">  int new_x, new_y, tmp;</span><br><span class="line">  // 随机空位置</span><br><span class="line">  do &#123;</span><br><span class="line">    new_x = rand() % 4;</span><br><span class="line">    new_y = rand() % 4;</span><br><span class="line">  &#125; while (a[new_y][new_x] != 0);</span><br><span class="line"></span><br><span class="line">  // 随机2,4数字</span><br><span class="line">  do &#123;</span><br><span class="line">    tmp = rand() % 4;</span><br><span class="line">  &#125; while (tmp == 0 || tmp == 2);</span><br><span class="line">  a[new_y][new_x] = tmp + 1;</span><br><span class="line">  empty--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="draw"><a href="#draw" class="headerlink" title="draw()"></a>draw()</h3><p>关键点在于横线和竖线for循环的对称性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// draw绘制方格和数字</span><br><span class="line">void draw() &#123;</span><br><span class="line">  int n, m, x, y;</span><br><span class="line"></span><br><span class="line">  clear();</span><br><span class="line">  for (n = 0; n &lt; 9; n += 2) //横线</span><br><span class="line">    for (m = 0; m &lt; 21; m++) &#123;</span><br><span class="line">      move(n, m);</span><br><span class="line">      addch(&apos;-&apos;);</span><br><span class="line">      refresh();</span><br><span class="line">    &#125;</span><br><span class="line">  for (m = 0; m &lt; 22; m += 5) //竖线</span><br><span class="line">    for (n = 1; n &lt; 8; n++) &#123;</span><br><span class="line">      move(n, m);</span><br><span class="line">      addch(&apos;|&apos;);</span><br><span class="line">      refresh();</span><br><span class="line">    &#125;</span><br><span class="line">  for (y = 0; y &lt; 4; y++) //数字</span><br><span class="line">    for (x = 0; x &lt; 4; x++) &#123;</span><br><span class="line">      draw_one(y, x);</span><br><span class="line">      if (a[y][x] == 2048) &#123;  // 胜利条件，出现2048</span><br><span class="line">        endflag = win;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="draw-one-int-y-int-x"><a href="#draw-one-int-y-int-x" class="headerlink" title="draw_one(int y, int x)"></a>draw_one(int y, int x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// draw_one 函数用于绘制单个数字</span><br><span class="line">void draw_one(int y, int x)</span><br><span class="line">&#123;</span><br><span class="line">    int i, m, k, j;</span><br><span class="line">    char c[4] = &#123;&apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;&#125;;// 个位、十位、百位、千位</span><br><span class="line"></span><br><span class="line">    i = a[y][x];</span><br><span class="line">    m = 0;</span><br><span class="line">    // 提取各位数到c[0-3]</span><br><span class="line">    do &#123;</span><br><span class="line">        j = i % 10;</span><br><span class="line">        c[m++] = j + &apos;0&apos;;</span><br><span class="line">        i = i / 10;</span><br><span class="line">    &#125;while(i &gt; 0);</span><br><span class="line"></span><br><span class="line">    //输出c[0-3]到恰当的位置</span><br><span class="line">    m = 0;</span><br><span class="line">    k = (x + 1) * 5 - 1;</span><br><span class="line">    while(c[m] != &apos;0&apos;) &#123;</span><br><span class="line">        move(2*y+1, k);</span><br><span class="line">        addch(c[m++]);</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="play"><a href="#play" class="headerlink" title="play()"></a>play()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 用 wsad 来表示上下左右方向</span><br><span class="line">void play() &#123;</span><br><span class="line"></span><br><span class="line">  int old_empty;</span><br><span class="line">  char ch;</span><br><span class="line"></span><br><span class="line">  while (1) &#123;</span><br><span class="line">    moved = 0;</span><br><span class="line">    old_empty = empty;</span><br><span class="line"></span><br><span class="line">    ch = getch();</span><br><span class="line">    switch (ch) &#123;</span><br><span class="line">    case &apos;A&apos;:</span><br><span class="line">    case &apos;a&apos;:</span><br><span class="line">      left();</span><br><span class="line">      break;</span><br><span class="line">    case &apos;D&apos;:</span><br><span class="line">    case &apos;d&apos;:</span><br><span class="line">      right();</span><br><span class="line">      break;</span><br><span class="line">    case &apos;W&apos;:</span><br><span class="line">    case &apos;w&apos;:</span><br><span class="line">      up();</span><br><span class="line">      break;</span><br><span class="line">    case &apos;S&apos;:</span><br><span class="line">    case &apos;s&apos;:</span><br><span class="line">      down();</span><br><span class="line">      break;</span><br><span class="line">    case &apos;Q&apos;:</span><br><span class="line">    case &apos;q&apos;:</span><br><span class="line">      endflag = quit;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw(); // 刷新</span><br><span class="line"></span><br><span class="line">    // 游戏失败</span><br><span class="line">    if (empty &lt;= 0 &amp;&amp; test_lose()) &#123;</span><br><span class="line">      endflag = lose;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断游戏结束条件</span><br><span class="line">    if (endflag != playing) &#123;</span><br><span class="line">      game_over();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成新方块</span><br><span class="line">    if ((empty != old_empty) ||</span><br><span class="line">        (moved == 1)) &#123; //修复了不移动或不消除方块也生成新方块的bug</span><br><span class="line">      add_number();</span><br><span class="line">      draw();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="left"><a href="#left" class="headerlink" title="left()"></a>left()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void left() &#123;</span><br><span class="line">  int x, y, i;</span><br><span class="line">  //从左向右消去相同方块</span><br><span class="line">  for (y = 0; y &lt; 4; y++)</span><br><span class="line">    for (x = 0; x &lt; 4;) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        x++;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = x + 1; i &lt; 4; i++) &#123;</span><br><span class="line">          if (a[y][i] == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (a[y][x] == a[y][i]) &#123;</span><br><span class="line">              a[y][x] += a[y][i];</span><br><span class="line">              a[y][i] = 0;</span><br><span class="line">              x = i + 1;</span><br><span class="line">              empty++;</span><br><span class="line">              break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              x = i;</span><br><span class="line">              break;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //向左移动方块</span><br><span class="line">  for (y = 0; y &lt; 4; y++)</span><br><span class="line">    for (x = 0; x &lt; 4; x++) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = x; (i &gt; 0) &amp;&amp; (a[y][i - 1] == 0); i--) &#123;</span><br><span class="line">          a[y][i - 1] = a[y][i];</span><br><span class="line">          a[y][i] = 0;</span><br><span class="line">          moved = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2016/07/11/demo-2048-c/left-non-zero.jpg" alt></p><h3 id="right"><a href="#right" class="headerlink" title="right()"></a>right()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void right() &#123;</span><br><span class="line">  int x, y, i;</span><br><span class="line">  //从右向左消去相同方块</span><br><span class="line">  for (y = 0; y &lt; 4; y++)</span><br><span class="line">    for (x = 3; x &gt;= 0;) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        x--;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = x - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">          if (a[y][i] == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125; else if (a[y][x] == a[y][i]) &#123;</span><br><span class="line">            a[y][x] += a[y][i];</span><br><span class="line">            a[y][i] = 0;</span><br><span class="line">            x = i - 1;</span><br><span class="line">            empty++;</span><br><span class="line">            break;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            x = i;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //向右移动方块</span><br><span class="line">  for (y = 0; y &lt; 4; y++)</span><br><span class="line">    for (x = 3; x &gt;= 0; x--) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = x; (i &lt; 3) &amp;&amp; (a[y][i + 1] == 0); i++) &#123;</span><br><span class="line">          a[y][i + 1] = a[y][i];</span><br><span class="line">          a[y][i] = 0;</span><br><span class="line">          moved = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="up"><a href="#up" class="headerlink" title="up()"></a>up()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void up() &#123;</span><br><span class="line">  int x, y, i;</span><br><span class="line">  //从上向下消去相同方块</span><br><span class="line">  for (x = 0; x &lt; 4; x++)</span><br><span class="line">    for (y = 0; y &lt; 4;) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        y++;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = y + 1; i &lt; 4; i++) &#123;</span><br><span class="line">          if (a[i][x] == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125; else if (a[y][x] == a[i][x]) &#123;</span><br><span class="line">            a[y][x] += a[i][x];</span><br><span class="line">            a[i][x] = 0;</span><br><span class="line">            y = i + 1;</span><br><span class="line">            empty++;</span><br><span class="line">            break;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            y = i;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        y = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //向上移动方块</span><br><span class="line">  for (x = 0; x &lt; 4; x++)</span><br><span class="line">    for (y = 0; y &lt; 4; y++) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = y; (i &gt; 0) &amp;&amp; (a[i - 1][x] == 0); i--) &#123;</span><br><span class="line">          a[i - 1][x] = a[i][x];</span><br><span class="line">          a[i][x] = 0;</span><br><span class="line">          moved = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="down"><a href="#down" class="headerlink" title="down()"></a>down()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void down() &#123;</span><br><span class="line">  int x, y, i;</span><br><span class="line">  //从下向上消去相同方块</span><br><span class="line">  for (x = 0; x &lt; 4; x++)</span><br><span class="line">    for (y = 3; y &gt;= 0;) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        y--;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = y - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">          if (a[i][x] == 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125; else if (a[y][x] == a[i][x]) &#123;</span><br><span class="line">            a[y][x] += a[i][x];</span><br><span class="line">            a[i][x] = 0;</span><br><span class="line">            y = i - 1;</span><br><span class="line">            empty++;</span><br><span class="line">            break;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            y = i;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        y = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //向下移动方块</span><br><span class="line">  for (x = 0; x &lt; 4; x++)</span><br><span class="line">    for (y = 3; y &gt;= 0; y--) &#123;</span><br><span class="line">      if (a[y][x] == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        for (i = y; (i &lt; 3) &amp;&amp; (a[i + 1][x] == 0); i++) &#123;</span><br><span class="line">          a[i + 1][x] = a[i][x];</span><br><span class="line">          a[i][x] = 0;</span><br><span class="line">          moved = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="test-lose"><a href="#test-lose" class="headerlink" title="test_lose()"></a>test_lose()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 判断矩阵各相邻数字是否相同，若都不同，则游戏失败</span><br><span class="line">int test_lose() &#123;</span><br><span class="line">  int y, x, j, i;</span><br><span class="line">  for (y = 0; y &lt; 3; y++)</span><br><span class="line">    for (x = 0; x &lt; 3; x++)</span><br><span class="line">      if (a[y][x] == a[y + 1][x] || a[y][x] == a[y][x + 1]) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line">  x = 3;</span><br><span class="line">  for (y = 0; y &lt; 3; y++)</span><br><span class="line">    if (a[y][3] == a[y + 1][3]) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">  y = 3;</span><br><span class="line">  for (x = 0; x &lt; 3; x++)</span><br><span class="line">    if (a[3][x] == a[3][x + 1]) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="game-over"><a href="#game-over" class="headerlink" title="game_over()"></a>game_over()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 游戏结束子函数</span><br><span class="line">int game_over() &#123;</span><br><span class="line"></span><br><span class="line">  draw_over();</span><br><span class="line">  sleep(1);</span><br><span class="line">  endwin();</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="draw-over"><a href="#draw-over" class="headerlink" title="draw_over()"></a>draw_over()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 游戏结束后绘制结束提醒</span><br><span class="line">void draw_over() &#123;</span><br><span class="line">  int y = 9, x = 0;</span><br><span class="line">  char output[30];</span><br><span class="line"></span><br><span class="line">  switch (endflag) &#123;</span><br><span class="line">  case playing:</span><br><span class="line">    strcpy(output, &quot;something wrong! &quot;);</span><br><span class="line">    break;</span><br><span class="line">  case lose:</span><br><span class="line">    strcpy(output, &quot;You lose! &quot;);</span><br><span class="line">    break;</span><br><span class="line">  case win:</span><br><span class="line">    strcpy(output, &quot;You win! &quot;);</span><br><span class="line">    break;</span><br><span class="line">  case quit:</span><br><span class="line">    strcpy(output, &quot;&quot;);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  strcat(output, &quot;Enter any key to quit.&quot;);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; output[i] != &apos;\0&apos;; i++, x++) &#123;</span><br><span class="line">    move(y, x);</span><br><span class="line">    addch(output[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  refresh();</span><br><span class="line">  char chtmp = getch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="testing"><a href="#testing" class="headerlink" title="testing"></a>testing</h2><h3 id="caution-compile"><a href="#caution-compile" class="headerlink" title="caution: compile "></a>caution: compile <!-- caution: compile --></h3><p>我们用了一个文本界面的屏幕绘图库 ncurses，编译时需要加上 -lcurses 选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure></p><p>编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc demo2048.c main.c -o demo -lcurses</span><br></pre></td></tr></table></figure></p><h3 id="error-re-define"><a href="#error-re-define" class="headerlink" title="error: re-define"></a>error: re-define</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/hzc/demo-2048-c/main.c:12: `a&apos;被多次定义</span><br><span class="line">/tmp/cctDvNiU.o:/home/hzc/demo-2048-c/demo2048c.c:11：第一次在此定义</span><br></pre></td></tr></table></figure><p>solution: declare <code>int a[4][4];</code> on <code>demo2048c.h</code>, define <code>int a[4][4] = {0};</code>on <code>int main()</code></p><h2 id="bonus"><a href="#bonus" class="headerlink" title="bonus"></a>bonus</h2><h3 id="MarkDown-jump"><a href="#MarkDown-jump" class="headerlink" title="MarkDown-jump"></a>MarkDown-jump</h3><p>markdown实现页内跳转:<code>[](#jump)</code><br>[]内可任意文本，点击即跳转到jump处，jump必须是标题级纯英文字母</p><h3 id="vim-ctags"><a href="#vim-ctags" class="headerlink" title="vim-ctags"></a>vim-ctags</h3><p><code>ctags -R</code> # 生成tags文件<br><code>ctrl+]</code> 跳转到函数定义处<br><code>ctrl+T</code> 回到函数被调用处</p><h3 id="gdb-tty"><a href="#gdb-tty" class="headerlink" title="gdb-tty"></a>gdb-tty</h3><p>tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb<br><code>tty</code> # echo /dev/pts/8<br><code>gdb demo-2048-c -tty /dev/pts/8</code>   </p><h3 id="ncurses"><a href="#ncurses" class="headerlink" title="ncurses"></a>ncurses</h3><p>[1] <a href="http://user.frdm.info/ckhung/b/mi/ncurses.php" target="_blank" rel="noopener">ncurses 文字模式下的特殊效果與遊標控制</a></p><blockquote><p>curses 是一個建構於 termcap/terminfo 之上的通用程式庫; ncurses 是 curses 的改良版本</p><ul><li>在 C 程式最前面, 要 #include &lt;curses/curses.h&gt; 並且在連結時要加 -lncurses</li><li>所有使用 ncurses 的程式, 一開始都要 initscr. 這會設定 ncurses 程式庫的初始狀態, 並且把程式執行之前的螢幕存起來.</li><li>所有使用 ncurses 的程式, 結束時都要 endwin. 這會讓 ncurses 程式庫做一些撿場的動作, 例如把螢幕恢復成程式執行之前的狀態.</li><li>為了提高執行效率, ncurses 中的大部分副程式所製造的效果, 都不是馬上會顯現出來的, 而是等到程式設計師呼叫 refresh 時才把先前所有指定的效果一次顯現出來.</li><li>cbreak 可讓終端機進入 “立即反應狀態”: 使用者只要敲一個鍵 (而不必按 Enter 鍵) 程式立即可以看到該字元 (透過 getch). 另一方面, noecho 可避免終端機當下就印出使用者敲進去的鍵, 而讓程式設計師自行安排在其他地方或時間才印出來 (甚或不印或印其他字串)</li></ul></blockquote><p>[2] <a href="http://www.freebsd.org/cgi/man.cgi?query=ncurses&amp;sektion=3&amp;apropos=0&amp;manpath=FreeBSD+7.0-RELEASE" target="_blank" rel="noopener">FreeBSD Man Pages for ncurses</a></p><blockquote><p>API manual</p><ul><li><a href="http://www.freebsd.org/cgi/man.cgi?query=curs_kernel&amp;sektion=3X&amp;apropos=0&amp;manpath=FreeBSD+7.0-RELEASE" target="_blank" rel="noopener">int curs_set(int visibility);</a><br>The curs_set routine sets the cursor state is set to invisible, normal,<br>or very visible for visibility equal to 0, 1, or 2  respectively.  </li><li><a href="http://www.freebsd.org/cgi/man.cgi?query=curs_move&amp;sektion=3X&amp;apropos=0&amp;manpath=FreeBSD+7.0-RELEASE" target="_blank" rel="noopener">int move(int y, int x);</a><br>These routines move the cursor associated with the window to line y and column x.<br>This routine does not move the physical cursor of the terminal until<br>refresh is called.  The position specified is relative to the<br>upper left-hand corner of the window, which is (0,0).  </li><li><a href="http://www.freebsd.org/cgi/man.cgi?query=curs_addch&amp;sektion=3X&amp;apropos=0&amp;manpath=FreeBSD+7.0-RELEASE" target="_blank" rel="noopener">int addch(const chtype ch);</a><br>The addch, waddch, mvaddch and mvwaddch routines put the character  ch<br>into the  given window at its current window position, which is then advanced.  </li></ul></blockquote><h2 id="update-log"><a href="#update-log" class="headerlink" title="update log"></a>update log</h2><p><strong>This project is based on <a href="https://www.shiyanlou.com/courses/running" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/running</a> </strong></p><ul><li>code refactoring</li><li>integrate new number into one function, introduce add_number()</li><li>add game over warning, introduce draw_over()</li><li>add endflag,when to quit, lose or win</li><li>add lose, introduce test_lose()</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序设计语言：C语言&lt;br&gt;游戏:2048&lt;br&gt;玩法：用WSAD控制上下左右方向,按Q退出游戏;&lt;br&gt;当两个&lt;strong&gt;相同&lt;/strong&gt;数字方块发生碰撞，它们会&lt;strong&gt;累加&lt;/strong&gt;起来成为一个新的数字方块，出现数字方块为2048时即可通关&lt;br&gt;源代码地址: &lt;a href=&quot;https://github.com/gitforhzc/demo-2048-c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gitforhzc/demo-2048-c&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#testing&quot;&gt;编译源代码&lt;/a&gt;，运行demo&lt;code&gt;./demo&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="game" scheme="http://gitforhzc.github.io/categories/game/"/>
    
    
      <category term="2048" scheme="http://gitforhzc.github.io/tags/2048/"/>
    
  </entry>
  
  <entry>
    <title>xx</title>
    <link href="http://gitforhzc.github.io/2016/07/06/xx/"/>
    <id>http://gitforhzc.github.io/2016/07/06/xx/</id>
    <published>2016-07-06T13:38:09.000Z</published>
    <updated>2019-06-08T11:05:57.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>love you</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="love" scheme="http://gitforhzc.github.io/categories/love/"/>
    
    
      <category term="private" scheme="http://gitforhzc.github.io/tags/private/"/>
    
  </entry>
  
</feed>
